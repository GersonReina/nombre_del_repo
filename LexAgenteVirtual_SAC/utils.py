import re
import time
from datetime import datetime, date, timedelta
import json
import requests
from redshift_utils import consultar_planes_redshift, consultar_invitados_redshift, consultar_incapacidades_redshift, consultar_referidos_redshift
from secret import obtener_secret, obtener_token_dinamico
from prompts import get_prompt_no_info, get_prompt_info
# --------------------- #
# FUNCIONES AUXILIARES  #
# --------------------- #

#############
# Respuesta #
#############

def responder(mensaje, session_attributes, intent_name, fulfillment_state="Fulfilled",slot_to_elicit=None):
    print("üì§ Enviando respuesta a Lex:", mensaje)
    response = {
        "sessionState": {
            "dialogAction": {
                "type": "ElicitSlot" if slot_to_elicit else "ElicitIntent"
            },
            "intent": {
                "name": intent_name,
                "state": fulfillment_state
            },
            "sessionAttributes": session_attributes
        },
        "messages": [
            {
                "contentType": "PlainText",
                "content": mensaje
            }
        ]
    }
    if slot_to_elicit:
        response["sessionState"]["dialogAction"]["slotToElicit"] = slot_to_elicit
    return response

#######################
# Cerrar Conversacion #
#######################

def cerrar_conversacion(mensaje, session_attributes=None):
    if session_attributes is None:
        session_attributes = {}
    session_attributes["esperando_calificacion"] = "true"
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "sessionAttributes": session_attributes
        },
        "messages": [
            {
                "contentType": "PlainText",
                "content": (
                            "¬°Gracias por usar nuestro servicio! üåü\n\n"
                            "¬øPodr√≠as calificar tu experiencia?\n\n"
                            "‚≠ê 1 estrella - Muy mala\n"
                            "‚≠ê‚≠ê 2 estrellas - Mala\n"
                            "‚≠ê‚≠ê‚≠ê 3 estrellas - Regular\n"
                            "‚≠ê‚≠ê‚≠ê‚≠ê 4 estrellas - Buena\n"
                            "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5 estrellas - Excelente\n\n"
                            "üí¨ **Responde con un n√∫mero del 1 al 5:**"
                        )
            }
        ],
    }

#######################
# Terminar sin calificaci√≥n #
#######################

def terminar_sin_calificacion(mensaje, session_attributes=None):
    """Termina la conversaci√≥n sin calificar cuando se rechazan pol√≠ticas"""
    if session_attributes is None:
        session_attributes = {}
    
    return {
        "sessionState": {
            "dialogAction": {"type": "Close"},
            "intent": {
                "name": "SaludoHabeasData", 
                "state": "Fulfilled"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": mensaje
        }]
    }

############################
# Sugerencias de intension #
############################

def mostrar_sugerencias(session_attributes):
    sugerencias = (
        "Lo siento, no logr√© identificar tu solicitud ü§î.\n"
        "Pero puedo ayudarte con:\n"
        "üìÑ Preguntas frecuentes\n"
        "üè¢ Sedes disponibles, horarios y actividades\n"
        "üìÖ Informaci√≥n sobre tu plan\n\n"
        "üë• Consultar invitados\n"
        "üèÜ Informaci√≥n sobre referidos\n"
        "üßæ Consultar incapacidades\n"
        "üõçÔ∏è Informaci√≥n de ventas\n"
        "‚ùÑÔ∏è Consultar congelaciones\n\n"
        "¬øSobre cu√°l tema necesitas ayuda?"
    )
    return responder(sugerencias, session_attributes, "FallbackIntent")


#####################
# Resumen de Planes #
#####################

def resumen_planes_para_bedrock(planes):
    if not planes:
        return "No hay planes activos para este usuario."
    if isinstance(planes, dict):
        planes = [planes]
    if not isinstance(planes, list):
        return "Error: formato de planes no reconocido."
    nombre = planes[0].get("full_name", "Usuario")
    resumen = f"Nombre: {nombre}\nPlanes:\n"
    for plan in planes:
        resumen += (
            f"‚Ä¢ Tipo de plan: {plan.get('product_name', 'N/A')}\n"
            f"  Estado: {'Activo ‚úÖ' if plan.get('line_status', 0) == 1 else 'Inactivo'}\n"
            f"  Inicio: {plan.get('date_start', 'N/A')}\n"
            f"  Vencimiento: {plan.get('date_end', 'N/A')}\n"
            f"  Sede: {plan.get('venue_use', 'N/A')}\n"
            f"  Recurrente: {'S√≠' if plan.get('is_recurring') else 'No'}\n"
            f"  Mora: {plan.get('mora', 'N/A')}\n"
            f"  Detalles: {json.dumps(plan, indent=2)}\n"
        )
    return resumen

##############################
# Convertir Fechas a Strings #
##############################

def convertir_fechas_a_str(obj):
    if isinstance(obj, dict):
        return {k: convertir_fechas_a_str(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convertir_fechas_a_str(i) for i in obj]
    elif hasattr(obj, 'isoformat'):
        return obj.isoformat()
    else:
        return obj

##################################
# Resumen Informacion Plan       # 
##################################

def obtener_resumen_plan(datos_plan: dict) -> str:
    try:
        data = datos_plan.get("data", {})
        nombre = f"{data.get('name', '')} {data.get('last_name', '')}".strip()
        planes = data.get("plans", [])
        resumen = f"Nombre: {nombre}\n"
        if not planes:
            return resumen + "No hay planes activos."
        for plan in planes:
            resumen += (
                f"\nTipo de plan: {plan.get('product_name')}\n"
                f"Estado: {'Activo ‚úÖ' if plan.get('line_status', 0) == 1 else 'Inactivo'}\n"
                f"Inicio: {plan.get('date_start')}\n"
                f"Vencimiento: {plan.get('date_end')}\n"
                f"proxima fecha de pago o corte: {plan.get('fecha_corte', 'N/A')}\n"
                f"Recurrente: {'S√≠' if plan.get('is_recurring') else 'No es recurrente'}\n"
                f"Categor√≠a: {plan.get('categoria', 'Sin categoria')}\n"
                f"Mora: {plan.get('mora', 'No se encuentra en mora')}\n"
                "----------------------"
            )
        return resumen.strip()
    except Exception as e:
        print("‚ùå Error generando resumen:", str(e))
        return "Informaci√≥n no disponible"

###############################
# Consulta Plan               # 
###############################

def consultar_plan(document_type, document_number):
    print("üìû Iniciando consulta de plan...")

    try:
        datos = consultar_planes_redshift(document_type, document_number)
        print("üîé Datos recibidos de Redshift:", datos)

        # Validaci√≥n reforzada
        if not datos or not isinstance(datos, list) or len(datos) == 0:
            print("‚ùå No se encontraron datos del plan en Redshift")
            return None, "No encontramos informaci√≥n del plan asociada a ese documento. Verifica los datos o intenta m√°s tarde."
        
        # Se extrae nombre y apellido del primer plan si existen
        primer_plan = datos[0] if datos else {}
        nombre = primer_plan.get("full_name", "").split()
        name = nombre[0] if nombre else ""
        last_name = " ".join(nombre[1:]) if len(nombre) > 1 else ""

        datos_formateados = {
            "data": {
                "name": name,
                "last_name": last_name,
                "plans": datos
            }
        }

        print("‚úÖ Datos del plan formateados correctamente")
        return datos_formateados, None
    except Exception as e:
        print("‚ùå Error al consultar el plan en Redshift:", str(e))
        return None, "Lo siento, hubo un problema consultando el plan. Intenta m√°s tarde."

###############################
# Consulta Plan es Recurrente # 
###############################

def obtener_is_recurring_desde_json(session_attributes):
    try:
        datos_json = session_attributes.get("datos_plan_json") or session_attributes.get("info_plan")
        if not datos_json:
            return None
        
        parsed = json.loads(datos_json)
        plans = parsed.get("data", {}).get("plans", [])
        if not plans:
            return None
        
        return plans[0].get("is_recurring", None)
    except Exception as e:
        print("‚ùå Error al extraer is_recurring:", str(e))
        return None

###############################
# Consulta Plan API # 
###############################

def consultar_plan_api(document_type, document_number):
    print("üìû Iniciando consulta de plan...")

    try:
        config = obtener_secret("main/LexAgenteVirtualSAC")
        api_url = config.get("API_URL_INFO_PLAN")
        access_token = obtener_token_dinamico(config)

        if not access_token:
            print("‚ùå ACCESS_TOKEN no encontrado en el secret.")
            return None, "Lo siento, hubo un problema autenticando tu solicitud. Intenta m√°s tarde."

        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}"
        }
        payload = {
            "document_type": str(document_type),
            "document_number": document_number
        }

        response = requests.post(api_url, json=payload, headers=headers, timeout=20)

        if response.status_code != 200:
            print(f"‚ùå Error en la llamada al API: {response.status_code} - {response.text}")
            return None, "No encontramos informaci√≥n del plan asociada a ese documento. Verifica los datos o intenta m√°s tarde."

        datos = response.json()
        print("‚úÖ Consulta de plan exitosa:", datos)
        return datos, None

    except Exception as e:
        print("‚ùå Error al consultar el plan:", str(e))
        return None, "Lo siento, hubo un problema consultando el plan. Intenta m√°s tarde."

###############################
# validar Fecha Valida 
###############################

def es_fecha_valida(fecha):
    # Valida formato YYYY-MM-DD
    return bool(re.match(r"^\d{4}-\d{2}-\d{2}$", fecha))


###############################
# Obtener resumen de clases grupales
###############################

def obtener_resumen_grupales(sede, clase, fecha, horarios):
    horarios_str = "\n".join(
        f"- {h['hora_inicio']} a {h['hora_fin']}" for h in horarios
    )
    return (
        f"Sede: {sede}\n"
        f"Clase: {clase}\n"
        f"Fecha: {fecha}\n"
        f"Horarios:\n{horarios_str}"
    )

###############################
# Resumen de invitados para Bedrock
###############################
def resumen_invitados_para_bedrock(datos_invitados: dict) -> str:
    invitados = datos_invitados.get("data", [])
    resumen = ""
    if not invitados:
        return (f"No tienes invitados registrados este a√±o. Te indico c√≥mo invitar a alguien:"
                  "Cualquier AFILIADO podr√° invitar por una (1) sola vez a una (1) persona que deber√° reunir las siguientes condiciones: (i) no estar afiliada, (ii) que su estado de afiliaci√≥n sea inactivo como m√≠nimo en los √∫ltimos tres (3) meses, (iii) que no tenga deudas pendientes con el Club M√©dico Deportivo BODYTECH, y (iv) que no haya disfrutado ninguna otra cortes√≠a en ese per√≠odo. Con la autorizaci√≥n previa del Gerente de la respectiva sede del Club M√©dico Deportivo BODYTECH, un AFILIADO podr√° invitar hasta tres (3) personas en forma simult√°nea. Los invitados deber√°n presentar documento de identidad, firmar el Contrato de Invitado, llenar el documento de Clasificaci√≥n de poblaci√≥n, atender las indicaciones del instructor durante su pr√°ctica y respetar las normas y reglamentos del Club M√©dico Deportivo BODYTECH. El Club M√©dico Deportivo BODYTECH se reserva el derecho de admisi√≥n de aquellos invitados cuya presentaci√≥n o condiciones personales al momento de solicitar el ingreso no est√©n acordes con la imagen p√∫blica del Club M√©dico Deportivo BODYTECH, tales como el uso de jean u otra clase de pantal√≥n no apto para la realizaci√≥n de la pr√°ctica deportiva, as√≠ como zapatos no apropiados. Las pol√≠ticas de admisi√≥n de Invitados est√°n sujetas a cambios, sin previo aviso.")

    for inv in invitados:
        resumen += (
            "Tus invitados registrados este a√±o son:\n"
            f"‚Ä¢ Nombre: {inv.get('nombre_invitado')}, "
            f"Documento: {inv.get('document_invitado')}, "
            f"Franquicia: {inv.get('franquicia')}, "
            f"Fecha de atenci√≥n: {inv.get('fecha_de_atencion')}\n"
        )
    return resumen.strip()
###############################
# Consultar invitados
###############################

def consultar_invitados(document_type, document_number):
    try:
        invitados = consultar_invitados_redshift(document_type, document_number)
        if not invitados:
            return None, "No se encontraron invitados asociados a este documento este a√±o. si deseas invitar a alguien estos son los pasos: \n"
        return {"data": invitados}, None
    except Exception as e:
        print("‚ùå Error al consultar invitados:", str(e))
        return None, "Ocurri√≥ un error consultando los invitados."
###############################
# Resumen de incapacidades para Bedrock
###############################

def resumen_incapacidades_para_bedrock(datos_incapacidades: dict) -> str:
    incapacidades = datos_incapacidades.get("data", [])
    if not incapacidades:
        return get_prompt_no_info("ConsultaIncapacidades", "")
    resumen = "Tus incapacidades activas son:\n"
    for inc in incapacidades:
        resumen += (
            f"‚Ä¢ Nombre: {inc.get('full_name')} ({inc.get('document_number')})\n"
            f"  Incapacidad: {inc.get('name')}\n"
            f"  Estado: {inc.get('status_issues')}\n"
            f"  Desde: {inc.get('date_start')} hasta {inc.get('date_end')}\n"
        )
    return resumen.strip()

###############################
# Consultar Incapacidades
###############################

def consultar_incapacidades(document_type, document_number):
    try:
        incapacidades = consultar_incapacidades_redshift(document_type, document_number)
        if not incapacidades:
            return None, "No tienes incapacidades activas registradas. Si necesitas reportar una incapacidad, comun√≠cate con tu sede o env√≠a el soporte m√©dico a trav√©s de la app Bodytech."
        return {"data": incapacidades}, None
    except Exception as e:
        print("‚ùå Error al consultar incapacidades:", str(e))
        return None, "Ocurri√≥ un error consultando las incapacidades."

###############################
# Resumen Referidos para Bedrock
###############################

def resumen_referidos_para_bedrock(datos_referidos: dict) -> str:
    referidos = datos_referidos.get("data", [])
    if not referidos:
        return ""  # Si no hay referidos, deja el resumen vac√≠o para que Bedrock use la KB
    resumen = "Tus referidos registrados este a√±o son:\n"
    for ref in referidos:
        resumen += (
            f"‚Ä¢ Nombre: {ref.get('name')} | Franquicia: {ref.get('franquicia')} | Fecha: {ref.get('fecha')} | Estado: {ref.get('status_plan')}\n"
        )
    return resumen.strip()

###############################
# Consultar Referidos
###############################

def consultar_referidos(document_type, document_number):
    try:
        referidos = consultar_referidos_redshift(document_type, document_number)
        return {"data": referidos}, None
    except Exception as e:
        print("‚ùå Error al consultar referidos:", str(e))
        return None, "Ocurri√≥ un error consultando los referidos."

###############################
# Resumen Ingresos para Bedrock
###############################

def resumen_ingresos_para_bedrock(datos):
    linea = datos.get("linea", "N/A")
    tipo = datos.get("tipo", "N/A")
    fecha_inicio = datos.get("fecha_inicio", "N/A")
    fecha_fin = datos.get("fecha_fin", "N/A")
    sede = datos.get("sede", "toda la compa√±√≠a" if tipo == "Total compa√±√≠a" else "N/A")
    ingresos = datos.get("ingresos", "N/A")
    if tipo == "Por sede":
        sede_str = f"Sede: {sede}"
    else:
        sede_str = "Total compa√±√≠a"
    return (
        f"L√≠nea: {linea}\n"
        f"{sede_str}\n"
        f"Fechas: {fecha_inicio} a {fecha_fin}\n"
        f"Ingresos: ${ingresos:,}"
    )

###############################
# Normalizar Fechas
############################### 

def normalizar_fecha(fecha_input):
    """Normaliza diferentes formatos de fecha a YYYY-MM-DD"""
    
    if not fecha_input:
        return None, "Por favor, indica una fecha v√°lida."
    
    fecha_input = str(fecha_input).strip().lower()
    print(f"üîç Normalizando fecha: '{fecha_input}'")
    
    try:
        a√±o_actual = datetime.now().year
        fecha_hoy = date.today()
        
        # Casos especiales mejorados
        if fecha_input in ["hoy", "today"]:
            fecha_normalizada = fecha_hoy.strftime("%Y-%m-%d")
            print(f"‚úÖ Fecha 'hoy': {fecha_normalizada}")
            return fecha_normalizada, None
            
        elif fecha_input in ["ma√±ana", "manana", "tomorrow"]:
            fecha_ma√±ana = fecha_hoy + timedelta(days=1)
            fecha_normalizada = fecha_ma√±ana.strftime("%Y-%m-%d")
            print(f"‚úÖ Fecha 'ma√±ana': {fecha_normalizada}")
            return fecha_normalizada, None
            
        elif fecha_input in ["ayer", "yesterday"]:
            fecha_ayer = fecha_hoy - timedelta(days=1)
            fecha_normalizada = fecha_ayer.strftime("%Y-%m-%d")
            print(f"‚úÖ Fecha 'ayer': {fecha_normalizada}")
            return fecha_normalizada, None

        # Formato "DD de MMMM" o "DD de MMMM de YYYY"
        patron_fecha_natural = r"(\d{1,2})\s+de\s+(\w+)(?:\s+de\s+(\d{4}))?"
        match_natural = re.search(patron_fecha_natural, fecha_input)
        
        if match_natural:
            dia = int(match_natural.group(1))
            mes_texto = match_natural.group(2).lower()
            a√±o = int(match_natural.group(3)) if match_natural.group(3) else a√±o_actual
            
            # Mapeo de meses en espa√±ol
            meses_map = {
                "enero": 1, "febrero": 2, "marzo": 3, "abril": 4, "mayo": 5, "junio": 6,
                "julio": 7, "agosto": 8, "septiembre": 9, "octubre": 10, "noviembre": 11, "diciembre": 12,
                "jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,
                "jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12
            }
            
            mes = meses_map.get(mes_texto)
            if mes:
                fecha_normalizada = f"{a√±o}-{mes:02d}-{dia:02d}"
                # Validar fecha
                datetime.strptime(fecha_normalizada, "%Y-%m-%d")
                print(f"‚úÖ Formato DD de MMMM: {fecha_normalizada}")
                return fecha_normalizada, None
            else:
                return None, f"No reconozco el mes '{mes_texto}'. Usa enero, febrero, marzo, etc."

        # : Formato con barras m√°s flexible
        if "/" in fecha_input:
            partes = [int(p) for p in fecha_input.split("/")]
            
            if len(partes) == 3:
                p1, p2, p3 = partes
                
                # Si el primer n√∫mero es > 1900, es YYYY/MM/DD
                if p1 > 1900:
                    fecha_normalizada = f"{p1}-{p2:02d}-{p3:02d}"
                # Si el tercer n√∫mero es > 1900, podr√≠a ser DD/MM/YYYY o MM/DD/YYYY
                elif p3 > 1900:
                    # Si p1 > 12, definitivamente es DD/MM/YYYY
                    if p1 > 12:
                        fecha_normalizada = f"{p3}-{p2:02d}-{p1:02d}"
                    # Si p2 > 12, definitivamente es MM/DD/YYYY  
                    elif p2 > 12:
                        fecha_normalizada = f"{p3}-{p1:02d}-{p2:02d}"
                    # Ambiguo - asumimos DD/MM/YYYY (formato colombiano)
                    else:
                        fecha_normalizada = f"{p3}-{p2:02d}-{p1:02d}"
                else:
                    # Formato de 2 d√≠gitos de a√±o - asumimos 20XX
                    a√±o_completo = 2000 + p3 if p3 < 50 else 1900 + p3
                    if p1 > 12:
                        fecha_normalizada = f"{a√±o_completo}-{p2:02d}-{p1:02d}"
                    else:
                        fecha_normalizada = f"{a√±o_completo}-{p2:02d}-{p1:02d}"
                
                # Validar fecha
                datetime.strptime(fecha_normalizada, "%Y-%m-%d")
                print(f"‚úÖ Formato con barras: {fecha_normalizada}")
                return fecha_normalizada, None
            
            # DD/MM (asume a√±o actual)
            elif len(partes) == 2:
                p1, p2 = partes
                if p1 > 12:
                    fecha_normalizada = f"{a√±o_actual}-{p2:02d}-{p1:02d}"
                else:
                    fecha_normalizada = f"{a√±o_actual}-{p2:02d}-{p1:02d}"
                
                datetime.strptime(fecha_normalizada, "%Y-%m-%d")
                print(f"‚úÖ Formato DD/MM: {fecha_normalizada}")
                return fecha_normalizada, None

        #  Formato solo n√∫meros m√°s flexible (DDMMYYYY, DDMM)
        if re.match(r"^\d+$", fecha_input):
            if len(fecha_input) == 8:  # DDMMYYYY o YYYYMMDD
                if fecha_input[:2] <= "31":  # Probablemente DDMMYYYY
                    dia = fecha_input[:2]
                    mes = fecha_input[2:4]
                    a√±o = fecha_input[4:8]
                else:  # Probablemente YYYYMMDD
                    a√±o = fecha_input[:4]
                    mes = fecha_input[4:6]
                    dia = fecha_input[6:8]
                fecha_normalizada = f"{a√±o}-{mes}-{dia}"
            elif len(fecha_input) == 4:  # DDMM
                dia = fecha_input[:2]
                mes = fecha_input[2:4]
                fecha_normalizada = f"{a√±o_actual}-{mes}-{dia}"
            elif len(fecha_input) == 3:  # DMM o DDM
                if int(fecha_input[0]) <= 3:  # DMM
                    dia = f"0{fecha_input[0]}"
                    mes = fecha_input[1:3]
                else:  # DDM
                    dia = fecha_input[:2]
                    mes = f"0{fecha_input[2]}"
                fecha_normalizada = f"{a√±o_actual}-{mes}-{dia}"
            elif len(fecha_input) == 2:  # DD (asume mes actual)
                mes_actual = fecha_hoy.month
                fecha_normalizada = f"{a√±o_actual}-{mes_actual:02d}-{fecha_input}"
            else:
                return None, "Formato de fecha no v√°lido."
            
            # Validar fecha
            datetime.strptime(fecha_normalizada, "%Y-%m-%d")
            print(f"‚úÖ Formato num√©rico: {fecha_normalizada}")
            return fecha_normalizada, None

        # Formato YYYY-MM-DD (ya correcto)
        if re.match(r"^\d{4}-\d{2}-\d{2}$", fecha_input):
            datetime.strptime(fecha_input, "%Y-%m-%d")
            print(f"‚úÖ Formato ISO: {fecha_input}")
            return fecha_input, None

        # Si no se pudo procesar
        return None, (
            "Formato de fecha no reconocido. Puedes usar:\n"
            "‚Ä¢ YYYY-MM-DD (2025-07-07)\n"
            "‚Ä¢ DD/MM/YYYY (07/07/2025)\n"
            "‚Ä¢ DD/MM (07/07)\n"
            "‚Ä¢ DD de MMMM (7 de julio)\n"
            "‚Ä¢ DD de MMMM de YYYY (7 de julio de 2025)\n"
            "‚Ä¢ 'hoy' o 'ma√±ana'"
        )
        
    except ValueError as e:
        print(f"‚ùå Error de validaci√≥n: {str(e)}")
        return None, "La fecha indicada no es v√°lida. Verifica el d√≠a y mes."
    except Exception as e:
        print(f"‚ùå Error procesando fecha: {str(e)}")
        return None, "Error procesando la fecha. Intenta con un formato diferente."

###############################
# Manjear Respuestas de informacion Adicional
###############################

def manejar_respuestas_info_adicional(session_attributes, input_transcript):
    from services import consultar_kb_bedrock
    from respuestas import consultar_bedrock_generacion
    
    mapeo_info = {
        "esperando_info_incapacidad": "ConsultaIncapacidades",
        "esperando_info_referidos": "FQAReferidos", 
        "esperando_info_invitados": "ConsultarInvitados",
        "esperando_info_sedes": "ConsultarSedes"
    }
    
    # Buscar qu√© tipo de informaci√≥n est√° esperando
    for attr_key, intent_name in mapeo_info.items():
        if session_attributes.get(attr_key) == "true":
            session_attributes.pop(attr_key, None)
            
            #  LIMPIAR EL FLUJO ACTIVO INMEDIATAMENTE
            session_attributes.pop("en_flujo_activo", None)
            
            #  CORRECCI√ìN: Detectar respuestas afirmativas sin clasificaci√≥n externa
            if any(palabra in input_transcript.strip().lower() for palabra in ["s√≠", "si", "quiero m√°s info", "quiero m√°s informaci√≥n", "si, quiero m√°s info", "si, quiero m√°s informaci√≥n"]):
                print(f"üîç Usuario pidi√≥ m√°s informaci√≥n para: {intent_name}")
                
                # Manejo espec√≠fico para cada intenci√≥n
                if intent_name == "FQAReferidos":
                    config = obtener_secret("main/LexAgenteVirtualSAC")
                    prompt = get_prompt_info(intent_name, input_transcript)
                    respuesta_kb = consultar_kb_bedrock(prompt, config["BEDROCK_KB_ID_FQAReferidos"])
                    mensaje_final = respuesta_kb.strip()
                elif intent_name == "ConsultaIncapacidades":
                    # Para incapacidades, usar generaci√≥n directa con prompt espec√≠fico
                    prompt = get_prompt_info(intent_name, "")
                    mensaje_final = consultar_bedrock_generacion(prompt)
                elif intent_name == "ConsultarInvitados":
                    # Para invitados, usar generaci√≥n directa con prompt espec√≠fico
                    prompt = get_prompt_info(intent_name, "")
                    mensaje_final = consultar_bedrock_generacion(prompt)
                else:
                    # Para otras intenciones, generaci√≥n directa
                    prompt = get_prompt_info(intent_name, "")
                    mensaje_final = consultar_bedrock_generacion(prompt)
                
                return responder_con_pregunta_final(mensaje_final, session_attributes, intent_name)
            
            elif any(palabra in input_transcript.strip().lower() for palabra in ["no", "no gracias", "no, gracias"]):
                print(f"üîç Usuario NO quiere m√°s informaci√≥n para: {intent_name}")
                return responder_con_pregunta_final("¬°Perfecto!", session_attributes, intent_name)
            
            elif intent_name == "ConsultarSedes":
                    # Para sedes, usar generaci√≥n directa con prompt espec√≠fico
                    prompt = get_prompt_info(intent_name, "")
                    mensaje_final = consultar_bedrock_generacion(prompt)
            
            else:
                print(f"üîç Respuesta ambigua para informaci√≥n de {intent_name}: '{input_transcript}'")
                # MANTENER EL FLUJO ACTIVO SOLO SI LA RESPUESTA ES AMBIGUA
                session_attributes["en_flujo_activo"] = intent_name
                session_attributes[attr_key] = "true"  # Volver a marcar esperando info
                
                return {
                    "sessionState": {
                        "dialogAction": {"type": "ElicitIntent"},
                        "sessionAttributes": session_attributes
                    },
                    "messages": [{
                        "contentType": "PlainText",
                        "content": "No entend√≠ tu respuesta. ¬øDeseas m√°s informaci√≥n sobre este tema?\n\nResponde: 'S√≠' o 'No'"
                    }]
                }
    
    return None
        
###############################
# Responder con pregunta Grupales
###############################

def esperando_respuesta_grupales(session_attributes, input_transcript, slots, intent):
    """
    Maneja toda la l√≥gica de transiciones para ConsultaGrupales
    """
    # Solo procesar si realmente est√° esperando transici√≥n Y hay flujo activo
    if (session_attributes.get("esperando_transicion_grupales") != "true" or 
        not session_attributes.get("en_flujo_activo")):
        return None
    
    input_lower = input_transcript.lower().strip()
    print(f"üîç Analizando transici√≥n grupales: '{input_lower}'")
    
    tipo_transicion_slot = slots.get("tipo_transicion", {}).get("value", {}).get("interpretedValue") if slots.get("tipo_transicion") else None

    # Prioridad: slot > input
    valor = tipo_transicion_slot or input_lower
    
    if input_lower in ["m", "menu", "men√∫", "menu principal", "men√∫ principal"]:
        print("üîÑ Usuario pidi√≥ ir al men√∫ principal")
        # Limpiar sesi√≥n y redirigir a men√∫ principal (puedes reutilizar tu l√≥gica de men√∫ principal aqu√≠)
        acepto_politicas = session_attributes.get("acepto_politicas")
        documento_attrs = {
            "document_type_id": session_attributes.get("document_type_id"),
            "document_type_raw": session_attributes.get("document_type_raw"),
            "document_number": session_attributes.get("document_number"),
            "intenciones_con_documento": session_attributes.get("intenciones_con_documento")
        }
        session_attributes.clear()
        for k, v in documento_attrs.items():
            if v is not None:
                session_attributes[k] = v
        if acepto_politicas == "true":
            session_attributes["acepto_politicas"] = "true"
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "Has regresado al men√∫ principal. ¬øEn qu√© puedo ayudarte?\n\n"
                    "Algunas opciones:\n"
                    "üìÑ Preguntas frecuentes sobre Bodytech\n"
                    "üè¢ Consultar sedes y horarios\n"
                    "üèÉ‚Äç‚ôÇÔ∏è Clases grupales disponibles\n"
                    "üìÖ Informaci√≥n de tu plan\n"
                    "üë• Consultar invitados\n"
                    "üèÜ Informaci√≥n sobre referidos\n"
                    "üßæ Consultar incapacidades\n"
                    "üõçÔ∏è Informaci√≥n de ventas\n"
                    "‚ùÑÔ∏è Consultar congelaciones\n"
                    "¬øSobre qu√© tema te gustar√≠a que te ayude?"
                )
            }]
        }
    # Detectar transiciones v√°lidas
    elif valor == "1":
        print("‚úÖ Transici√≥n detectada: OTRA CIUDAD")
        return _procesar_otra_ciudad(session_attributes)
    elif valor == "2":
        print("‚úÖ Transici√≥n detectada: OTRA SEDE")
        return _procesar_otra_sede(session_attributes)
    elif valor == "3":
        print("‚úÖ Transici√≥n detectada: OTRA CLASE")
        return _procesar_otra_clase(session_attributes)
    elif valor == "4":
        print("‚úÖ Transici√≥n detectada: OTRA FECHA")
        return _procesar_otra_fecha(session_attributes)
    elif (input_lower in ["no", "no gracias", "5"] or 
          any(p in input_lower for p in ["no", "nada", "gracias", "eso es todo", "ninguna", "no gracias", "nada mas"])):
        print("‚úÖ Transici√≥n detectada: NO M√ÅS CONSULTAS")
        # Procesar directamente aqu√≠ usando responder_con_pregunta_final
        return _procesar_no_mas_consultas(session_attributes)
    
    # Si no se detecta transici√≥n v√°lida, mostrar error
    print(f"‚ùå Transici√≥n no reconocida: '{input_transcript}'")
    return _mostrar_error_transicion(session_attributes)

def _procesar_otra_sede(session_attributes):
    """Procesa transici√≥n a otra sede"""
    print("‚úÖ Transici√≥n: OTRA SEDE")
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    
    if not ciudad_actual:
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultaGrupales", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{"contentType": "PlainText", "content": "¬øEn qu√© ciudad deseas consultar otra sede?"}]
        }
    
    # Limpiar solo sede y clase, mantener ciudad
    keys_to_remove = ["sede_nombre", "sede_id", "categoria_clase_preguntada", "clase_display", "slots_previos"]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Configurar nuevo intent para ConsultaGrupales con ciudad
    slots_nuevos = {
        "ciudad": {
            "value": {
                "originalValue": ciudad_actual,
                "resolvedValues": [ciudad_actual],
                "interpretedValue": ciudad_actual
            },
            "shape": "Scalar"
        }
    }
    
    # Limpiar la bandera de transici√≥n
    session_attributes.pop("esperando_transicion_grupales", None)
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "sede"},
            "intent": {
                "name": "ConsultaGrupales",
                "state": "InProgress",
                "slots": slots_nuevos
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": f"¬°Perfecto! Te ayudo a consultar otra sede en {ciudad_actual}. ¬øEn qu√© sede deseas consultar?"
        }]
    }

def _mostrar_error_transicion(session_attributes):
    """Muestra mensaje de error cuando no se reconoce la transici√≥n"""
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "intent": {"name": "ConsultaGrupales", "state": "Fulfilled"},
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "ü§î No entend√≠ tu respuesta. Por favor, selecciona una opci√≥n v√°lida:\n\n"
                "1Ô∏è‚É£ Otra ciudad\n"
                "2Ô∏è‚É£ Otra sede\n"
                "3Ô∏è‚É£ Otra clase\n"
                "4Ô∏è‚É£ Otra fecha\n"
                "5Ô∏è‚É£ No gracias\n\n"
                "üè† M Men√∫ principal\n\n"
                "Responde con el n√∫mero (1, 2, 3, 4, 5 √≥ M para volver al menu principal):"
            )
        }]
    }


def _procesar_otra_ciudad(session_attributes):
    """Procesa transici√≥n a otra ciudad"""
    print("‚úÖ Transici√≥n: OTRA CIUDAD")
    
    # Limpiar toda la informaci√≥n geogr√°fica
    keys_to_remove = [
        "categoria_clase_preguntada", "clase_display", "slots_previos",
        "sede_nombre", "sede_id", "ciudad_nombre", "ciudad_id", "ciudad"
    ]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Limpiar la bandera de transici√≥n
    session_attributes.pop("esperando_transicion_grupales", None)
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
            "intent": {
                "name": "ConsultaGrupales",
                "state": "InProgress",
                "slots": {}
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": "¬°Perfecto! üåé ¬øEn qu√© ciudad deseas consultar las clases grupales?"
        }]
    }


def _procesar_otra_clase(session_attributes):
    """Procesa transici√≥n a otra clase"""
    print("‚úÖ Transici√≥n: OTRA CLASE")
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    sede_actual = session_attributes.get("sede_nombre")
    sede_id = session_attributes.get("sede_id")
    
    if not ciudad_actual or not sede_actual:
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultaGrupales", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{"contentType": "PlainText", "content": "¬øEn qu√© ciudad y sede deseas consultar otra clase?"}]
        }
    print(f"‚úÖ Ciudad: {ciudad_actual}, Sede: {sede_actual}, Sede ID: {sede_id}")
    
    # Limpiar solo clase info, mantener ciudad y sede
    keys_to_remove = ["clase_display", "slots_previos"]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Limpiar la bandera de transici√≥n
    session_attributes.pop("esperando_transicion_grupales", None)
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    print("‚úÖ Configurando slots para mantener ciudad y sede")
    
    # Configurar slots manteniendo ciudad y sede
    slots_nuevos = {
        "ciudad": {
            "value": {
                "originalValue": ciudad_actual,
                "resolvedValues": [ciudad_actual],
                "interpretedValue": ciudad_actual
            },
            "shape": "Scalar"
        },
        "sede": {
            "value": {
                "originalValue": sede_actual,
                "resolvedValues": [sede_actual],
                "interpretedValue": sede_actual
            },
            "shape": "Scalar"
        }
    }
    
    print("‚úÖ Slots configurados, construyendo respuesta")
    
    # Construir mensaje con clases disponibles si es posible
    try:
        # Intentar obtener clases disponibles
        if sede_id:
            from redshift_utils import consultar_clases_por_sede_id
            clases = consultar_clases_por_sede_id(sede_id)
            
            if clases and len(clases) > 0:
                # Extraer nombres de clases
                clases_nombres = []
                for clase in clases:
                    if isinstance(clase, dict) and 'clase' in clase:
                        clases_nombres.append(clase['clase'])
                    elif isinstance(clase, str):
                        clases_nombres.append(clase)
                
                if clases_nombres:
                    mensaje_clases = (
                        f"¬°Perfecto! Te ayudo a consultar otra clase en {sede_actual}, {ciudad_actual}. üèÉ‚Äç‚ôÇÔ∏è\n\n"
                        f"üìã **Clases disponibles:**\n\n"
                        + "\n".join(f"‚Ä¢ {clase}" for clase in clases_nombres)  # Limitar a 10
                        + "\n\nüí¨ ¬øCu√°l clase deseas consultar?"
                    )
                else:
                    mensaje_clases = f"¬°Perfecto! Te ayudo a consultar otra clase en {sede_actual}, {ciudad_actual}. üèÉ‚Äç‚ôÇÔ∏è\n\n¬øQu√© clase deseas consultar?"
            else:
                mensaje_clases = f"¬°Perfecto! Te ayudo a consultar otra clase en {sede_actual}, {ciudad_actual}. üèÉ‚Äç‚ôÇÔ∏è\n\n¬øQu√© clase deseas consultar?"
        else:
            mensaje_clases = f"¬°Perfecto! Te ayudo a consultar otra clase en {sede_actual}, {ciudad_actual}. üèÉ‚Äç‚ôÇÔ∏è\n\n¬øQu√© clase deseas consultar?"
    except Exception as e:
        print(f"‚ö†Ô∏è Error obteniendo clases: {str(e)}")
        mensaje_clases = f"¬°Perfecto! Te ayudo a consultar otra clase en {sede_actual}, {ciudad_actual}. üèÉ‚Äç‚ôÇÔ∏è\n\n¬øQu√© clase deseas consultar?"
    
    print(f"‚úÖ Mensaje construido: {mensaje_clases[:100]}...")
    
    respuesta = {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "clase"},
            "intent": {
                "name": "ConsultaGrupales",
                "state": "InProgress",
                "slots": slots_nuevos
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": mensaje_clases
        }]
    }
    
    print("‚úÖ Respuesta construida correctamente")
    return respuesta



def _procesar_otra_fecha(session_attributes):
    """Procesa transici√≥n a otra fecha manteniendo ciudad, sede y clase"""
    print("‚úÖ Transici√≥n: OTRA FECHA")
    
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    sede_actual = session_attributes.get("sede_nombre")
    clase_actual = session_attributes.get("clase_nombre")
    
    if not ciudad_actual or not sede_actual:
        print("‚ùå Faltan datos de ciudad o sede para otra fecha")
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultaGrupales", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{"contentType": "PlainText", "content": "¬øEn qu√© ciudad y sede deseas consultar otra fecha?"}]
        }
    
    # Limpiar solo datos espec√≠ficos de fecha, mantener todo lo dem√°s
    keys_to_remove = ["fecha", "esperando_transicion_grupales"]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Configurar slots manteniendo ciudad, sede y clase (si existe)
    slots_nuevos = {
        "ciudad": {
            "value": {
                "originalValue": ciudad_actual,
                "resolvedValues": [ciudad_actual],
                "interpretedValue": ciudad_actual
            },
            "shape": "Scalar"
        },
        "sede": {
            "value": {
                "originalValue": sede_actual,
                "resolvedValues": [sede_actual],
                "interpretedValue": sede_actual
            },
            "shape": "Scalar"
        }
    }
    
    # Si hay clase espec√≠fica, mantenerla tambi√©n
    if clase_actual:
        slots_nuevos["clase"] = {
            "value": {
                "originalValue": clase_actual,
                "resolvedValues": [clase_actual],
                "interpretedValue": clase_actual
            },
            "shape": "Scalar"
        }
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar {clase_actual} en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    else:
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar las clases en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    
    # Marcar que estamos en flujo activo
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    print(f"‚úÖ Par√°metros mantenidos - Ciudad: {ciudad_actual}, Sede: {sede_actual}, Clase: {clase_actual or 'Todas'}")
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "fecha"},
            "intent": {
                "name": "ConsultaGrupales",
                "slots": slots_nuevos,
                "state": "InProgress"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": f"{mensaje_fecha}\n\n¬øPara qu√© fecha deseas consultar? Puedes escribir:\n‚Ä¢ YYYY-MM-DD (2025-01-15)\n‚Ä¢ DD de MMMM (15 de enero)\n‚Ä¢ DD/MM (15/01)\n‚Ä¢ 'hoy' o 'ma√±ana'"
        }]
    }


def _procesar_no_mas_consultas(session_attributes):
    """Procesa cuando el usuario no quiere m√°s consultas - AQU√ç VA LA PREGUNTA FINAL"""
    print("‚úÖ Usuario no desea m√°s consultas - enviando pregunta final")
    
    # Limpiar todo de ConsultaGrupales
    keys_to_remove = [
        "en_flujo_activo", "clase_display", "slots_previos",
        "ciudad_nombre", "sede_nombre", "ciudad_id", "sede_id",
        "esperando_transicion_grupales"
    ]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # USAR responder_con_pregunta_final en lugar de crear respuesta manual
    return responder_con_pregunta_final(
        "¬°Perfecto! üòä", 
        session_attributes, 
        "ConsultaGrupales"
    )

###############################
# Actualizar men√∫s de transici√≥n ConsultaGrupales
###############################

def actualizar_menu_transicion_grupales():
    """
    Funci√≥n para actualizar todos los men√∫s de transici√≥n de ConsultaGrupales
    agregando la opci√≥n '5Ô∏è‚É£ No gracias' donde falte
    """
    import fileinput
    import sys
    
    archivo = '/Users/gerson.reina/Documents/LexAgenteVirtual_SAC/lambda_function.py'
    
    # Patr√≥n a buscar y reemplazar
    patron_viejo = '"4Ô∏è‚É£ Otra fecha\\n"\n                                "üè† M Men√∫ principal\\n\\n"'
    patron_nuevo = '"4Ô∏è‚É£ Otra fecha\\n"\n                                "5Ô∏è‚É£ No gracias\\n\\n"\n                                "üè† M Men√∫ principal\\n\\n"'
    
    # Leer archivo y hacer reemplazos
    with open(archivo, 'r', encoding='utf-8') as f:
        contenido = f.read()
    
    # Hacer el reemplazo
    contenido_actualizado = contenido.replace(
        '"4Ô∏è‚É£ Otra fecha\\n"\n                                "üè† M Men√∫ principal\\n\\n"',
        '"4Ô∏è‚É£ Otra fecha\\n"\n                                "5Ô∏è‚É£ No gracias\\n\\n"\n                                "üè† M Men√∫ principal\\n\\n"'
    )
    
    # Tambi√©n actualizar el patr√≥n con m√°s espacios (para las variaciones)
    contenido_actualizado = contenido_actualizado.replace(
        '"4Ô∏è‚É£ Otra fecha\\n"\n                                        "üè† M Men√∫ principal\\n\\n"',
        '"4Ô∏è‚É£ Otra fecha\\n"\n                                        "5Ô∏è‚É£ No gracias\\n\\n"\n                                        "üè† M Men√∫ principal\\n\\n"'
    )
    
    # Escribir archivo actualizado
    with open(archivo, 'w', encoding='utf-8') as f:
        f.write(contenido_actualizado)
    
    print("‚úÖ Men√∫s de transici√≥n ConsultaGrupales actualizados correctamente")

###############################
# Manejar Transicion ConsultarSedes
###############################

def esperando_respuesta_sedes(session_attributes, input_transcript, slots, intent):
    """
    Maneja toda la l√≥gica de transiciones para ConsultarSedes
    """
    # Solo procesar si realmente est√° esperando transici√≥n Y hay flujo activo
    if (session_attributes.get("esperando_transicion_sedes") != "true" or 
        not session_attributes.get("en_flujo_activo")):
        return None
    
    input_lower = input_transcript.lower().strip()
    print(f"üîç Analizando transici√≥n sedes: '{input_lower}'")
    
    if input_lower in ["m", "menu", "men√∫", "menu principal", "men√∫ principal"]:
        print("üîÑ Usuario pidi√≥ ir al men√∫ principal")
        # Limpiar sesi√≥n y redirigir a men√∫ principal (puedes reutilizar tu l√≥gica de men√∫ principal aqu√≠)
        acepto_politicas = session_attributes.get("acepto_politicas")
        documento_attrs = {
            "document_type_id": session_attributes.get("document_type_id"),
            "document_type_raw": session_attributes.get("document_type_raw"),
            "document_number": session_attributes.get("document_number"),
            "intenciones_con_documento": session_attributes.get("intenciones_con_documento")
        }
        session_attributes.clear()
        for k, v in documento_attrs.items():
            if v is not None:
                session_attributes[k] = v
        if acepto_politicas == "true":
            session_attributes["acepto_politicas"] = "true"
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "Has regresado al men√∫ principal. ¬øEn qu√© puedo ayudarte?\n\n"
                    "Algunas opciones:\n"
                    "üìÑ Preguntas frecuentes sobre Bodytech\n"
                    "üè¢ Consultar sedes y horarios\n"
                    "üèÉ‚Äç‚ôÇÔ∏è Clases grupales disponibles\n"
                    "üìÖ Informaci√≥n de tu plan\n"
                    "üë• Consultar invitados\n"
                    "üèÜ Informaci√≥n sobre referidos\n"
                    "üßæ Consultar incapacidades\n"
                    "üõçÔ∏è Informaci√≥n de ventas\n"
                    "‚ùÑÔ∏è Consultar congelaciones\n"
                    "¬øSobre qu√© tema te gustar√≠a que te ayude?"
                )
            }]
        }
    # Detectar transiciones v√°lidas
    if "otra ciudad" in input_lower or input_lower == "1":
        print("‚úÖ Transici√≥n detectada: OTRA CIUDAD")
        return _procesar_otra_ciudad_sedes(session_attributes)
    elif "otra sede" in input_lower or input_lower == "2":
        print("‚úÖ Transici√≥n detectada: OTRA SEDE") 
        return _procesar_otra_sede_sedes(session_attributes, slots, intent)  # ‚úÖ CAMBIO AQU√ç
    elif (input_lower in ["no", "no gracias", "3"] or 
          any(p in input_lower for p in ["no", "nada", "gracias", "eso es todo", "ninguna", "no gracias", "nada mas"])):
        print("‚úÖ Transici√≥n detectada: NO M√ÅS CONSULTAS")
        return _procesar_no_mas_consultas_sedes(session_attributes)
    
    # Si no se detecta transici√≥n v√°lida, mostrar error
    print(f"‚ùå Transici√≥n no reconocida: '{input_transcript}'")
    return _mostrar_error_transicion_sedes(session_attributes)

def _procesar_otra_ciudad_sedes(session_attributes):
    """Procesa transici√≥n a otra ciudad para ConsultarSedes"""
    print("‚úÖ Transici√≥n: OTRA CIUDAD")
    
    # Limpiar toda la informaci√≥n geogr√°fica
    keys_to_remove = [
        "ciudad", "ciudad_id", "ciudad_nombre", 
        "pregunta_categoria", "consultando_horarios",
        # üÜï AGREGAR ESTAS L√çNEAS PARA LIMPIAR SEDE ANTERIOR
        "sede_id",
        "sede_nombre",
        "tipo_consulta_temporal",
        "input_original_menu",
        "procesar_con_datos_extraidos"
    ]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Limpiar la bandera de transici√≥n
    session_attributes.pop("esperando_transicion_sedes", None)
    session_attributes["en_flujo_activo"] = "ConsultarSedes"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
            "intent": {
                "name": "ConsultarSedes",
                "state": "InProgress",
                "slots": {}
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": "¬°Perfecto! üåé ¬øEn qu√© ciudad deseas consultar las sedes?"
        }]
    }

def _procesar_otra_sede_sedes(session_attributes, slots, intent):
    """Procesa la transici√≥n 'otra sede' para ConsultarSedes"""
    print("‚úÖ Transici√≥n: OTRA SEDE")
    
    # Obtener ciudad actual
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    ciudad_id = session_attributes.get("ciudad_id")
    
    if not ciudad_actual:
        print("‚ùå No hay ciudad actual para otra sede")
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultarSedes", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": "¬øEn qu√© ciudad deseas consultar las sedes?"
            }]
        }
    
    print(f"‚úÖ Manteniendo ciudad: {ciudad_actual}")
    print(f"‚úÖ Ciudad ID: {ciudad_id}")
    
    keys_to_remove = [
        "esperando_transicion_sedes", 
        "consultando_horarios",
        "sede_id",  
        "sede_nombre",  
        "tipo_consulta_temporal",  
        "input_original_menu",  
        "procesar_con_datos_extraidos"  
    ]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    session_attributes["pregunta_categoria"] = None
    session_attributes["en_flujo_activo"] = "ConsultarSedes"
    
    print("‚úÖ Configurando para continuar flujo normal...")
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
            "intent": {
                "name": "ConsultarSedes",
                "state": "InProgress",
                "slots": {
                    "ciudad": {
                        "value": {
                            "originalValue": ciudad_actual,
                            "resolvedValues": [ciudad_actual],
                            "interpretedValue": ciudad_actual
                        },
                        "shape": "Scalar"
                    }
                }
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": f"¬°Perfecto! Te ayudo a consultar otra sede en {ciudad_actual}. ¬øEn qu√© ciudad deseas consultar ahora? üè¢"
        }]
    }

def _procesar_no_mas_consultas_sedes(session_attributes):
    """Procesa cuando el usuario no quiere m√°s consultas de sedes"""
    print("‚úÖ Usuario no quiere m√°s consultas")
    
    # Limpiar todo y enviar pregunta final
    keys_to_remove = [
        "en_flujo_activo", "ciudad", "ciudad_id", "ciudad_nombre", 
        "pregunta_categoria", "consultando_horarios", "esperando_transicion_sedes"
    ]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    return responder_con_pregunta_final("¬°Perfecto! üòä", session_attributes, "ConsultarSedes")

def _mostrar_error_transicion_sedes(session_attributes):
    """Muestra mensaje de error cuando no se reconoce la transici√≥n de sedes"""
    contenido = (
        "ü§î No entend√≠ tu respuesta. Por favor, selecciona una opci√≥n v√°lida:\n\n"
        "1Ô∏è‚É£ Otra ciudad\n"
        "2Ô∏è‚É£ Otra sede\n"
        "3Ô∏è‚É£ No gracias\n\n"
        "üè† M Men√∫ principal\n\n"
        "Responde con el n√∫mero (1, 2, 3 √≥ M para volver al menu principal):"
    )
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "intent": {"name": "ConsultarSedes", "state": "Fulfilled"},
            "sessionAttributes": session_attributes
        },
        "messages": [{"contentType": "PlainText", "content": contenido}]
    }

###############################
# Responder Calificaci√≥n
###############################

def obtener_intent_detectado(event):

    try:
        return event.get("sessionState", {}).get("intent", {}).get("name", "")
    except Exception as e:
        print(f"‚ùå Error obteniendo intent detectado: {str(e)}")
        return ""

def responder_con_pregunta_final(mensaje, session_attributes, intent_name):
    print("üîç ===== DEBUG responder_con_pregunta_final =====")
    print(f"üîç intent_name: {intent_name}")
    print(f"üîç session_attributes recibidos: {session_attributes}")
    
    
    # Si el usuario menciona una nueva intenci√≥n
    if intent_name in ["ConsultarSedes"]:
        # Limpiar sessionAttributes relacionados con la intenci√≥n anterior
        session_attributes = {"acepto_politicas": session_attributes.get("acepto_politicas", "true")}
        # Iniciar el intent desde cero
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {
                    "name": intent_name,
                    "slots": {},  # Vac√≠o, para empezar desde cero
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": "¬øEn qu√© ciudad deseas consultar los horarios de sede?"
            }]
        }
        
    if intent_name == "ConsultaGrupales":
        print("üîç Intent es ConsultaGrupales - si marcando esperando_respuesta_final")
        # Limpiar datos espec√≠ficos de ConsultaGrupales pero mantener ciudad/sede si existen
        keys_to_remove = ["clase_display", "slots_previos"]
        for key in keys_to_remove:
            session_attributes.pop(key, None)
        
        # NO marcar esperando_respuesta_final para ConsultaGrupales
        session_attributes["esperando_respuesta_final"] = "true"
        session_attributes.pop("en_flujo_activo", None)
        
        contenido = f"{mensaje}\n\n¬øNecesitas ayuda con algo m√°s? üòä\n\nüí¨ Responde 'S√≠' para ver el men√∫ principal o 'No' para finalizar."
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "intent": {
                    "name": intent_name, 
                    "state": "Fulfilled"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": contenido
            }]
        }
    
    # Para todas las dem√°s intenciones, comportamiento normal
    session_attributes.pop("en_flujo_activo", None)
    
    session_attributes.pop("clase_display", None)
    session_attributes.pop("slots_previos", None)
    session_attributes["esperando_respuesta_final"] = "true"
    
    contenido = f"{mensaje}\n\n¬øNecesitas ayuda con algo m√°s? üòä\n\nüí¨ Responde 'S√≠' para ver el men√∫ principal o 'No' para finalizar."
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "intent": {
                "name": intent_name, 
                "state": "Fulfilled"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": contenido
        }]
    }
# Funci√≥n para manejo de informaci√≥n adicional
def crear_respuesta_info_adicional(mensaje_final, session_attributes, intent_name, flag_key):
    session_attributes[flag_key] = "true"
    

    contenido = f"{mensaje_final}\n\n¬øDeseas m√°s informaci√≥n sobre este tema?\n\nResponde: 'S√≠' o 'No'"

    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": contenido
        }]
    }

def manejar_consulta_horarios(intent, session_attributes, slots, input_transcript):
    print("Entrando a manejar_consulta_horarios")
    tipo_horario = slots.get("tipo_horario")
    if not tipo_horario:
        # Preguntar primero el tipo de horario
        return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "tipo_horario"},
            "intent": {
                "name": "ConsultaHorarios",
                "slots": slots,
                "state": "InProgress"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "¬øQu√© tipo de horarios deseas consultar? üìÖ\n\n"
                "üèÉ‚Äç‚ôÇÔ∏è **Clases grupales** - Horarios de actividades espec√≠ficas\n"
                "üè¢ **Sede** - Horarios de atenci√≥n general\n\n"
                "üí¨ **Responde:** 'Clases grupales' o 'Sede'"
            )
        }]
    }
    # Aqu√≠ defines tu condici√≥n real
    if input_transcript.strip().lower() in ["no", "no gracias"]:
        print("Retornando responder_con_pregunta_final desde manejar_consulta_horarios")
        return responder_con_pregunta_final(
            "¬°Perfecto! üòä",
            session_attributes,
            "ConsultaHorarios"
        )

    print("Saliendo de manejar_consulta_horarios sin return")
    return None

###############################
# Verificar si es input valido
###############################

def es_input_valido(input_transcript):
    """
    Valida si el input del usuario es texto coherente o solo caracteres sin sentido
    """
    import re
    
    # Limpiar el input
    texto_limpio = input_transcript.strip().lower()
    
    # 1. Si est√° vac√≠o, es inv√°lido
    if not texto_limpio:
        return False
    
    # ‚úÖ NUEVO: Si es solo n√∫meros (posible documento), es v√°lido
    if texto_limpio.isdigit() and 4 <= len(texto_limpio) <= 15:
        print(f"‚úÖ Input v√°lido (n√∫mero de documento): '{texto_limpio}'")
        return True
    
    # 2. Si es solo n√∫meros largos sin sentido (m√°s de 15 d√≠gitos)
    if texto_limpio.isdigit() and len(texto_limpio) > 15:
        return False
    
    # 3. Si tiene m√°s del 70% de caracteres repetidos o sin sentido
    caracteres_unicos = len(set(texto_limpio.replace(" ", "")))
    total_caracteres = len(texto_limpio.replace(" ", ""))
    
    if total_caracteres > 5 and caracteres_unicos / total_caracteres < 0.3:
        print(f"üö´ Texto con pocos caracteres √∫nicos: {caracteres_unicos}/{total_caracteres}")
        return False
    
    # 4. ‚úÖ MEJORAR: Detectar patrones de tecleo aleatorio (pero excluir palabras v√°lidas)
    # Lista de palabras v√°lidas que pueden tener muchas consonantes
    palabras_validas_consonantes = [
        "country", "centro", "rumba", "spinning", "crossfit", "strength", "strong",
        "chapinero", "normandia", "outlet", "portal", "tintal", "hayuelos", "cedritos",
        "horarios", "tienen", "grupales", "clases", "horario", "consultar"
    ]
    
    # Solo aplicar filtro de consonantes si NO contiene palabras v√°lidas conocidas
    contiene_palabra_valida = any(palabra in texto_limpio for palabra in palabras_validas_consonantes)
    
    if not contiene_palabra_valida:
        patron_sin_sentido = re.compile(r'[bcdfghjklmnpqrstvwxyz]{6,}')  # Aumentar umbral a 6
        if patron_sin_sentido.search(texto_limpio):
            print(f"üö´ Patr√≥n de consonantes detectado: {texto_limpio}")
            return False
    
    # 5. Detectar secuencias de teclado obvias
    secuencias_teclado = [
        'qwerty', 'asdf', 'zxcv', 'qaz', 'wsx', 'edc', 'rfv', 'tgb', 'yhn', 'ujm',
        'qlllq', 'asklj', 'lkjh', 'mnbv', 'poiu', 'wert', 'dfgh', 'cvbn'
    ]
    
    for secuencia in secuencias_teclado:
        if secuencia in texto_limpio:
            print(f"üö´ Secuencia de teclado detectada: {secuencia}")
            return False
    
    # 6. Si es muy corto pero no tiene sentido (menos de 3 caracteres v√°lidos)
    if len(texto_limpio.replace(" ", "")) < 3 and not any(palabra in texto_limpio for palabra in [
        "si", "no", "ok", "hola", "bye", "m", "n", "1", "2", "3", "4", "5", "6", "7", "8", "9"
    ]):
        return False
    
    # 7. Detectar si NO tiene ninguna vocal (excepto n√∫meros y palabras muy cortas)
    if (len(texto_limpio) > 2 and 
        not re.search(r'[aeiou√°√©√≠√≥√∫]', texto_limpio) and 
        not texto_limpio.isdigit()):  # ‚úÖ AGREGAR esta condici√≥n
        print(f"üö´ Texto sin vocales: {texto_limpio}")
        return False
    
    print(f"‚úÖ Input v√°lido: '{texto_limpio}'")
    return True

def procesar_input_original_sedes(input_original, session_attributes):
    """
    Procesa el input original para extraer autom√°ticamente datos de ConsultarSedes
    """
    print(f"üéØ Procesando input original para ConsultarSedes: '{input_original}'")
    print(f"üîç DEBUG session_attributes recibidos: {session_attributes}")
    
    try:
        # Importar la funci√≥n de extracci√≥n de sedes
        from services import extraer_y_validar_slots_sedes
        
        # Crear un intent mock
        intent_mock = {
            "name": "ConsultarSedes",
            "slots": {}
        }
        
        print(f"üîç Llamando extraer_y_validar_slots_sedes con: input='{input_original}', intent={intent_mock}")
        
        # Procesar el input original
        resultado = extraer_y_validar_slots_sedes(input_original, session_attributes, intent_mock)
        
        print(f"üîç Resultado de extracci√≥n autom√°tica: {resultado}")
        print(f"üîç Tipo de resultado: {type(resultado)}")
        
        if resultado:
            print(f"üîç Keys en resultado: {list(resultado.keys()) if isinstance(resultado, dict) else 'No es dict'}")
            
        # Si la funci√≥n devuelve una respuesta directa (consulta exitosa)
        if resultado and resultado.get("sessionState"):
            print("‚úÖ Extracci√≥n exitosa - devolviendo respuesta directa")
            return resultado
        
        # Si es consulta directa, EJECUTAR la consulta real
        if resultado and resultado.get("consulta_directa") == True:
            print("‚úÖ Consulta directa detectada - EJECUTANDO CONSULTA REAL")
            
            # Extraer datos necesarios
            sede_id = resultado.get("sede_id")
            sede_nombre = resultado.get("sede_nombre")
            ciudad_nombre = resultado.get("ciudad_nombre")
            tipo_consulta = resultado.get("tipo_consulta")
            
            print(f"üîç Datos extra√≠dos - sede_id: {sede_id}, sede_nombre: {sede_nombre}, tipo_consulta: {tipo_consulta}")
            
            # EJECUTAR LA CONSULTA REAL seg√∫n el tipo
            if tipo_consulta == "horarios_sede" and sede_id:
                print(f"üéØ Ejecutando consulta de horarios para sede {sede_nombre} (ID: {sede_id})")
                
                # Importar funci√≥n de consulta de horarios
                from redshift_utils import consultar_horarios_sede
                from respuestas import respuesta_bedrock
                
                # Ejecutar consulta real
                horarios = consultar_horarios_sede(sede_id)
                
                if not horarios:
                    mensaje_final = f"No se encontraron horarios para la sede {sede_nombre.title()}."
                else:
                    print(f"‚úÖ Horarios encontrados: {len(horarios) if isinstance(horarios, list) else 'datos disponibles'}")
                    # Generar respuesta con Bedrock
                    mensaje_final = respuesta_bedrock("ConsultarSedes", horarios)
                    if not mensaje_final or not mensaje_final.strip():
                        mensaje_final = f"Horarios de atenci√≥n de la sede {sede_nombre} en {ciudad_nombre}:\n\nüìÖ Consulta completada exitosamente."
                
                # session_attributes con los datos
                if resultado.get("session_attributes"):
                    for key, value in resultado["session_attributes"].items():
                        if isinstance(value, (str, int, float, bool)):
                            session_attributes[key] = str(value)
                
                # CONFIGURAR PARA PREGUNTA DE TRANSICI√ìN
                session_attributes["esperando_transicion_sedes"] = "true"
                session_attributes["en_flujo_activo"] = "ConsultarSedes"
                
                return {
                    "sessionState": {
                        "dialogAction": {"type": "ElicitSlot", "slotToElicit": "tipo_transicion"},
                        "intent": {
                            "name": "ConsultarSedes",
                            "state": "InProgress",
                            "slots": {}
                        },
                        "sessionAttributes": session_attributes
                    },
                    "messages": [{
                        "contentType": "PlainText",
                        "content": (
                            f"{mensaje_final}\n\n"
                            "¬øDeseas hacer otra consulta de sedes? üè¢\n\n"
                            "Selecciona una opci√≥n:\n"
                            "1Ô∏è‚É£ Otra ciudad\n"
                            "2Ô∏è‚É£ Otra sede\n"
                            "3Ô∏è‚É£ No gracias\n\n"
                            "üè† M Men√∫ principal\n"
                            "üí¨ Escribe el n√∫mero de tu opci√≥n o M para volver al men√∫ principal:"
                        )
                    }]
                }
            
            # OTROS TIPOS DE CONSULTA (categoria_especifica, sede_especifica, etc.)
            elif tipo_consulta == "sede_especifica" and sede_id:
                print(f"üéØ Ejecutando consulta espec√≠fica para sede {sede_nombre}")
                
                from redshift_utils import consultar_horarios_sede
                from respuestas import respuesta_bedrock
                
                horarios = consultar_horarios_sede(sede_id)
                if not horarios:
                    mensaje_final = f"No se encontraron horarios para la sede {sede_nombre.title()}."
                else:
                    mensaje_final = respuesta_bedrock("ConsultarSedes", horarios)
                    if not mensaje_final or not mensaje_final.strip():
                        mensaje_final = f"Informaci√≥n de la sede {sede_nombre} en {ciudad_nombre}."
                
                # Actualizar session_attributes y configurar transici√≥n
                if resultado.get("session_attributes"):
                    for key, value in resultado["session_attributes"].items():
                        if isinstance(value, (str, int, float, bool)):
                            session_attributes[key] = str(value)
                
                session_attributes["esperando_transicion_sedes"] = "true"
                session_attributes["en_flujo_activo"] = "ConsultarSedes"
                
                return {
                    "sessionState": {
                        "dialogAction": {"type": "ElicitSlot", "slotToElicit": "tipo_transicion"},
                        "intent": {
                            "name": "ConsultarSedes",
                            "state": "InProgress",
                            "slots": {}
                        },
                        "sessionAttributes": session_attributes
                    },
                    "messages": [{
                        "contentType": "PlainText",
                        "content": (
                            f"{mensaje_final}\n\n"
                            "¬øDeseas hacer otra consulta de sedes? üè¢\n\n"
                            "Selecciona una opci√≥n:\n"
                            "1Ô∏è‚É£ Otra ciudad\n"
                            "2Ô∏è‚É£ Otra sede\n" 
                            "3Ô∏è‚É£ No gracias\n\n"
                            "üè† M Men√∫ principal\n"
                            "üí¨ Escribe el n√∫mero de tu opci√≥n o M para volver al men√∫ principal:"
                        )
                    }]
                }
            
            # Si no se puede ejecutar consulta directa, continuar flujo normal mejorado
            else:
                print("‚ö†Ô∏è Consulta directa detectada pero no se puede ejecutar - mejorando flujo normal")
                
                # Actualizar session_attributes con datos extra√≠dos
                if resultado.get("session_attributes"):
                    for key, value in resultado["session_attributes"].items():
                        if isinstance(value, (str, int, float, bool)):
                            session_attributes[key] = str(value)
                
                session_attributes["input_original_menu"] = str(input_original)
                session_attributes["mejoramiento_sedes"] = "true"
                
                return {
                    "sessionState": {
                        "dialogAction": {"type": "ElicitIntent"},
                        "intent": {
                            "name": "ConsultarSedes",
                            "state": "InProgress",
                            "slots": {}
                        },
                        "sessionAttributes": session_attributes
                    },
                    "messages": [{
                        "contentType": "PlainText",
                        "content": f"¬°Perfecto! Te ayudo a consultar informaci√≥n de {sede_nombre if sede_nombre else 'sedes'} üè¢"
                    }]
                }
        
        # Si se detectaron par√°metros parciales (ej: solo ciudad), seguir flujo normal con datos
        if resultado and (resultado.get("ciudad_id") or resultado.get("sede_id") or resultado.get("categoria_nombre")):
            print("‚úÖ Par√°metros parciales detectados - mejorando flujo normal")
            
            # Actualizar session_attributes con solo strings
            if resultado.get("ciudad_id"):
                session_attributes["ciudad_id"] = str(resultado["ciudad_id"])
            if resultado.get("ciudad_nombre"):
                session_attributes["ciudad_nombre"] = str(resultado["ciudad_nombre"])
            if resultado.get("sede_id"):
                session_attributes["sede_id"] = str(resultado["sede_id"])
            if resultado.get("sede_nombre"):
                session_attributes["sede_nombre"] = str(resultado["sede_nombre"])
            
            session_attributes["input_original_menu"] = str(input_original)
            session_attributes["mejoramiento_sedes"] = "true"
            
            return {
                "sessionState": {
                    "dialogAction": {"type": "ElicitIntent"},
                    "intent": {
                        "name": "ConsultarSedes",
                        "state": "InProgress",
                        "slots": {}
                    },
                    "sessionAttributes": session_attributes
                },
                "messages": [{
                    "contentType": "PlainText",
                    "content": "¬°Perfecto! Te ayudo a consultar informaci√≥n de sedes y horarios üè¢"
                }]
            }
        
        # Si no se pudo extraer autom√°ticamente, seguir flujo normal
        print("‚ö†Ô∏è No se pudieron extraer datos autom√°ticamente - siguiendo flujo normal")
        return None
        
    except Exception as e:
        print(f"‚ùå Error procesando input original para sedes: {str(e)}")
        return None

def manejar_timeout_sesion(session_attributes, input_transcript=""):
    """
    Maneja el timeout de sesi√≥n con flujo de 3 min + 2 min
    - 3 min sin respuesta: pregunta si puede ayudar en algo m√°s
    - 2 min adicionales sin respuesta: finaliza la sesi√≥n
    """
    import time
    
    # Obtener timestamp actual
    timestamp_actual = int(time.time())
    
    ultimo_intercambio = session_attributes.get("ultimo_intercambio")
    primer_aviso_timestamp = session_attributes.get("primer_aviso_timeout")
    esperando_respuesta_timeout = session_attributes.get("esperando_respuesta_timeout")
    
    # Si no hay timestamp, es la primera interacci√≥n
    if not ultimo_intercambio:
        session_attributes["ultimo_intercambio"] = str(timestamp_actual)
        return None
    
    # Calcular tiempo transcurrido desde la √∫ltima interacci√≥n
    tiempo_inactivo = timestamp_actual - int(ultimo_intercambio)
    
    print(f"üïê Tiempo inactivo: {tiempo_inactivo} segundos")
    
    # ===== CASO 1: PRIMERA INACTIVIDAD (3 minutos) =====
    if tiempo_inactivo > 180 and not primer_aviso_timestamp:  # 3 minutos = 180 segundos
        print("‚è∞ PRIMER TIMEOUT (3 min) - Preguntando si necesita ayuda")
        session_attributes["primer_aviso_timeout"] = str(timestamp_actual)
        session_attributes["esperando_respuesta_timeout"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "ü§î He notado que ha pasado un tiempo sin actividad.\n\n"
                    "¬øPuedo ayudarte en algo m√°s?\n\n"
                    "üí¨ Responde 's√≠' si necesitas ayuda o cualquier consulta que tengas."
                )
            }]
        }
    
    # ===== CASO 2: YA SE HIZO LA PRIMERA PREGUNTA =====
    elif primer_aviso_timestamp and esperando_respuesta_timeout == "true":
        tiempo_desde_primer_aviso = timestamp_actual - int(primer_aviso_timestamp)
        
        # Si hay input del usuario, procesar su respuesta
        if input_transcript.strip():
            print(f"‚úÖ Usuario respondi√≥ despu√©s del primer aviso: '{input_transcript}'")
            
            # Limpiar flags de timeout
            session_attributes.pop("esperando_respuesta_timeout", None)
            session_attributes.pop("primer_aviso_timeout", None)
            
            # Actualizar timestamp de √∫ltima actividad
            session_attributes["ultimo_intercambio"] = str(timestamp_actual)
            
            # Procesar la respuesta
            respuesta_normalizada = input_transcript.lower().strip()
            
            # Respuestas afirmativas - continuar sesi√≥n
            if any(palabra in respuesta_normalizada for palabra in [
                "si", "s√≠", "ayuda", "necesito", "quiero", "claro", "vale", "ok", "yes"
            ]):
                return mostrar_menu_principal(session_attributes)
            
            # Respuestas negativas - finalizar sesi√≥n amigablemente
            elif any(palabra in respuesta_normalizada for palabra in [
                "no", "nada", "gracias", "finalizar", "terminar", "adi√≥s", "bye", "chao"
            ]):
                return finalizar_sesion_timeout_negativa()
            
            # Respuesta no clara - dar una oportunidad m√°s
            else:
                return {
                    "sessionState": {
                        "dialogAction": {"type": "ElicitIntent"},
                        "sessionAttributes": session_attributes
                    },
                    "messages": [{
                        "contentType": "PlainText",
                        "content": (
                            "ü§î No entend√≠ tu respuesta.\n\n"
                            "¬øNecesitas ayuda con algo m√°s?\n\n"
                            "üí¨ Responde 's√≠' para continuar o 'no' para finalizar."
                        )
                    }]
                }
        
        # ===== CASO 3: SIN RESPUESTA DESPU√âS DE 2 MINUTOS ADICIONALES =====
        elif tiempo_desde_primer_aviso > 120:  # 2 minutos = 120 segundos
            print("‚è∞ TIMEOUT FINAL (2 min adicionales) - Finalizando sesi√≥n autom√°ticamente")
            return finalizar_sesion_timeout_automatico()
    
    # ===== ACTUALIZAR TIMESTAMP EN INTERACCIONES NORMALES =====
    if input_transcript.strip():
        session_attributes["ultimo_intercambio"] = str(timestamp_actual)
    
    return None

def finalizar_sesion_timeout_negativa():
    """
    Finaliza la sesi√≥n cuando el usuario dice que no necesita m√°s ayuda
    """
    return {
        "sessionState": {
            "dialogAction": {"type": "Close"},
            "intent": {
                "name": "TimeoutFinalizado",
                "state": "Fulfilled"
            },
            "sessionAttributes": {"conversacion_finalizada": "true"}
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "¬°Gracias por contactarte con Bodytech! üòä\n\n"
                "Ha sido un placer ayudarte. Que tengas un excelente d√≠a.\n\n"
                "Puedes iniciar una nueva conversaci√≥n cuando lo desees."
            )
        }]
    }

def finalizar_sesion_timeout_automatico():
    """
    Finaliza la sesi√≥n autom√°ticamente por falta de respuesta
    """
    return {
        "sessionState": {
            "dialogAction": {"type": "Close"},
            "intent": {
                "name": "TimeoutFinalizado", 
                "state": "Fulfilled"
            },
            "sessionAttributes": {"conversacion_finalizada": "true"}
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "‚è∞ **Sesi√≥n finalizada por inactividad**\n\n"
                "No hemos recibido respuesta en los √∫ltimos minutos, "
                "por lo que hemos cerrado la conversaci√≥n.\n\n"
                "¬°Gracias por contactarte con Bodytech! üòä\n"
                "Puedes iniciar una nueva conversaci√≥n cuando lo desees."
            )
        }]
    }

###############################
# Men√∫ Principal Interactivo
###############################

def mostrar_menu_principal(session_attributes):
    """
    Muestra el men√∫ principal con opciones numeradas para navegar a cada intenci√≥n
    """
    menu_contenido = (
        "Perfecto! ¬øEn qu√© puedo ayudarte?\n\n"
        "1Ô∏è‚É£ üìã **Preguntas frecuentes sobre BodyTech**\n"
        "2Ô∏è‚É£ üè¢ **Consultar sedes y horarios**\n" 
        "3Ô∏è‚É£ üèÉ‚Äç‚ôÇÔ∏è **Clases grupales disponibles**\n"
        "4Ô∏è‚É£ üí™ **Informaci√≥n de tu plan**\n"
        "5Ô∏è‚É£ üë• **Consultar invitados**\n"
        "6Ô∏è‚É£ üèÜ **Informaci√≥n sobre referidos**\n"
        "7Ô∏è‚É£ üßæ **Consultar incapacidades**\n"
        "8Ô∏è‚É£ üíº **Informaci√≥n de ventas**\n"
        "9Ô∏è‚É£ ‚ùÑÔ∏è **Sobre tema de congelaciones**\n\n"
        "üö™ **N** - No quiero m√°s ayuda (Finalizar la Conversaci√≥n)\n\n"
        "üí¨ Tambi√©n puedes escribir directamente en qu√© necesitas ayuda\n"
        "üîô Recuerda que siempre puedes escribir la **M** para volver al men√∫ principal\n\n"
        "Responde con el **n√∫mero** de tu opci√≥n (1-9), **N** para finalizar √≥ escribeme tu consulta:"
    )
    
    session_attributes["esperando_seleccion_menu"] = "true"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": menu_contenido
        }]
    }

def procesar_seleccion_menu(input_transcript, session_attributes):
    """
    Procesa la selecci√≥n del usuario del men√∫ principal
    Permite tanto n√∫meros (1-9, N) como texto libre
    """
    print(f"üîç Procesando selecci√≥n: '{input_transcript}'")
    
    input_limpio = input_transcript.strip().lower()
    
    # Mapeo de opciones a intenciones
    opciones_menu = {
        "1": "FQABodytech",
        "2": "ConsultarSedes", 
        "3": "ConsultaGrupales",
        "4": "ConsultaInfoPlan",
        "5": "ConsultarInvitados",
        "6": "FQAReferidos",
        "7": "ConsultaIncapacidades",
        "8": "Venta",
        "9": "CongelarPlan"
    }
    
    # Limpiar la bandera del men√∫
    session_attributes.pop("esperando_seleccion_menu", None)
    
    # PRIORIDAD 1: Opci√≥n N - Finalizar conversaci√≥n
    if input_limpio in ["n", "no", "no quiero mas ayuda", "finalizar", "terminar"]:
        print("üö™ Usuario eligi√≥ finalizar desde men√∫ principal")
        return cerrar_conversacion("¬°Perfecto! Vamos a finalizar.", session_attributes)
    
    # PRIORIDAD 2: Opciones 1-9 - Redirigir a intenciones
    elif input_limpio in opciones_menu:
        intent_seleccionado = opciones_menu[input_limpio]
        print(f"‚úÖ Usuario seleccion√≥ opci√≥n {input_limpio}: {intent_seleccionado}")
        
        resultado_redireccion = redirigir_a_intencion(intent_seleccionado, session_attributes)
        
        # ‚úÖ MANEJAR EL CASO CUANDO RETORNA None
        if resultado_redireccion is None:
            print("üîÑ Redireccion retorn√≥ None - necesita procesar en lambda_handler")
            # Retornar datos para que lambda_handler contin√∫e el flujo
            return {
                "continuar_flujo": True,
                "intent_name": intent_seleccionado,
                "session_attributes": session_attributes
            }
        else:
            # Si la redirecci√≥n retorna una respuesta, enviarla
            return resultado_redireccion
    
    # VALIDACI√ìN PREVIA: Verificar si el input tiene sentido antes de enviar a Bedrock
    elif not es_input_valido(input_transcript):
        print(f"üö´ Input inv√°lido detectado: '{input_transcript}' - No enviando a Bedrock")
        
        session_attributes["esperando_seleccion_menu"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    f"ü§î No entend√≠ tu entrada: '{input_transcript}'\n\n"
                    "Por favor, usa:\n"
                    "‚Ä¢ **N√∫meros del 1 al 9** para opciones espec√≠ficas\n"
                    "‚Ä¢ ** √≥ Texto claro** como 'horarios de yoga', 'info de mi plan', 'consulta de plan' etc..\n"
                    "‚Ä¢ **N** para finalizar\n\n"
                    "üí¨ ¬øQu√© te gustar√≠a hacer?"
                )
            }]
        }
    
    # PRIORIDAD 3: Permitir texto libre y clasificar con Bedrock
    else:
        print(f"üîç Texto libre detectado: '{input_transcript}' - Analizando clasificaci√≥n")
        
        # üÜï FUNCIONES DE NORMALIZACI√ìN LOCAL
        def normalizar_texto_busqueda(texto):
            """Normaliza texto para b√∫squeda: quita tildes, convierte a min√∫sculas, etc."""
            import unicodedata
            texto = texto.lower().strip()
            # Quitar tildes y caracteres especiales
            texto_sin_tildes = ''.join(c for c in unicodedata.normalize('NFD', texto) 
                                     if unicodedata.category(c) != 'Mn')
            return texto_sin_tildes
        
        def corregir_clases_comunes(texto):
            """Corrige errores comunes en nombres de clases"""
            correcciones_clases = {
                # Errores de tipeo comunes
                "yga": "yoga", "yogga": "yoga", "ioga": "yoga",
                "piltes": "pilates", "pilats": "pilates", "pilaties": "pilates",
                "samba": "zumba", "sumba": "zumba", "kumba": "zumba",
                "spining": "spinning", "spinnig": "spinning", "espin": "spinning",
                "rumbas": "rumba", "rumva": "rumba", "runba": "rumba",
                "acqua": "aqua", "agua": "aqua", "akua": "aqua",
                "funcinal": "funcional", "funcinal": "funcional",
                "crosfit": "crossfit", "crossfitt": "crossfit","cycling": "cyclingtech", "cyclintech"
                # Variaciones locales
                "aerobicos": "aerobicos", "aerovicos": "aerobicos",
                "abdominales": "abdomen", "abs": "abdomen",
                "gluteos": "gl√∫teos", "gluteoss": "gl√∫teos",
                "natacion": "natacion", "nataciom": "natacion"
            }
            
            texto_normalizado = normalizar_texto_busqueda(texto)
            for error, correccion in correcciones_clases.items():
                if error in texto_normalizado:
                    texto_normalizado = texto_normalizado.replace(error, correccion)
            return texto_normalizado
        
        def corregir_sedes_comunes(texto):
            """Corrige errores comunes en nombres de sedes"""
            correcciones_sedes = {
                # Errores de tipeo comunes
                "normandie": "normandia", "normadie": "normandia", "normadia": "normandia",
                "chiko": "chico", "chic": "chico",
                "centro maior": "centro mayor", "centromayor": "centro mayor",
                "chapinro": "chapinero", "chaponero": "chapinero",
                "zona roza": "zona rosa", "zonarosa": "zona rosa",
                "unicentro": "unicentro", "uni centro": "unicentro",
                "santafe": "santafe", "santa fe": "santafe",
                "carrera15": "carrera 15", "carrera quinze": "carrera 15",
                "cedritos": "cedritos", "sedritos": "cedritos",
                "hayuelos": "hayuelos", "alleuelos": "hayuelos",
                "buenavista": "buenavista", "buena vista": "buenavista",
                "outlets": "outlet", "outllet": "outlet",
                # AGREGAR CORRECCIONES PARA COUNTRY
                "contry": "country", "countri": "country", "cuntry": "country",
                "club country": "country", "country club": "country",
                # Ciudades comunes mal escritas
                "bogot": "bogota", "bogote": "bogota", "bogto": "bogota",
                "medelin": "medellin", "medelein": "medellin", "medallo": "medellin",
                "bucamaranga": "bucaramanga", "bucaranga": "bucaramanga",
                "cucta": "cucuta", "cuccuta": "cucuta",
                "baranquilla": "barranquilla", "varranquilla": "barranquilla"
            }
            
            texto_normalizado = normalizar_texto_busqueda(texto)
            for error, correccion in correcciones_sedes.items():
                if error in texto_normalizado:
                    texto_normalizado = texto_normalizado.replace(error, correccion)
            return texto_normalizado
        
        # üÜï DETECCI√ìN LOCAL MEJORADA CON NORMALIZACI√ìN
        clases_conocidas = [
            "yoga", "pilates", "zumba", "spinning", "rumba", "danza", "aqua", "funcional", 
            "crossfit", "bodypump", "bodycombat", "bodybalance", "bodyattack", "gap",
            "abdomen", "gl√∫teos", "stretching", "power", "strong", "bootcamp", "natacion",
            "aquaerobicos", "boxeo", "kickboxing", "tabata", "hiit", "cardio", "aerobicos",
            "step", "bailoterapia", "ritmos", "salsa", "bachata", "merengue", "twerk", "cycling", "cyclintech"
        ]
        
        # Palabras clave que indican consulta de clases grupales
        palabras_clave_grupales = ["horario", "horarios", "clase", "clases", "actividad", "actividades"]
        
        # üÜï NORMALIZAR EL INPUT ANTES DE BUSCAR
        input_normalizado = corregir_clases_comunes(input_transcript)
        input_lower = input_normalizado.lower()
        
        print(f"üîç Input original: '{input_transcript}'")
        print(f"üîç Input normalizado: '{input_normalizado}'")
        
        # Si menciona una clase conocida + palabra clave, es definitivamente ConsultaGrupales
        for clase in clases_conocidas:
            if (clase in input_lower and 
                any(palabra in input_lower for palabra in palabras_clave_grupales)):
                print(f"‚úÖ Detecci√≥n local: '{clase}' + palabra clave encontrada en '{input_transcript}' ‚Üí ConsultaGrupales")
                session_attributes["input_original_menu"] = input_transcript
                return redirigir_a_intencion("ConsultaGrupales", session_attributes)
        
        # Tambi√©n detectar patrones espec√≠ficos sin necesidad de palabra clave adicional
        patrones_directos = [
            "horarios de", "horario de", "clases de", "clase de", 
            "que horarios", "qu√© horarios", "cuando es", "cu√°ndo es",
            "a que hora", "a qu√© hora"
        ]
        
        for patron in patrones_directos:
            if patron in input_lower:
                for clase in clases_conocidas:
                    if clase in input_lower:
                        print(f"‚úÖ Detecci√≥n local directa: patr√≥n '{patron}' + clase '{clase}' ‚Üí ConsultaGrupales")
                        session_attributes["input_original_menu"] = input_transcript
                        return redirigir_a_intencion("ConsultaGrupales", session_attributes)
        
        # üÜï DETECCI√ìN DE SEDES + CLASES CON NORMALIZACI√ìN
        sedes_conocidas = [
            "normandia", "chico", "cali", "centro mayor", "chapinero", "zona rosa", 
            "unicentro", "santafe", "carrera 15", "cedritos", "suba", "hayuelos",
            "portal", "buenavista", "outlet", "tunal", "americas", "tintal",
            "country", "country club", "club country",  # ‚úÖ AGREGAR ESTAS L√çNEAS
            "barranquilla", "cartagena", "monteria", "valledupar", "santa marta",
            "bucaramanga", "cucuta", "pereira", "manizales", "armenia", "ibague",
            "neiva", "pasto", "popayan", "villavicencio"
        ]
        
        # üÜï NORMALIZAR TAMBI√âN LAS SEDES EN EL INPUT
        input_normalizado_sedes = corregir_sedes_comunes(input_normalizado)
        
        # üÜï DETECCI√ìN ESPEC√çFICA PARA CONSULTAS DE HORARIOS DE SEDE
        palabras_horarios_sede = ["horarios", "horario", "atencion", "atenci√≥n", "abren", "cierran", "abre", "cierra"]
        
        # Detectar patr√≥n: "horarios" + "en" + sede ‚Üí ConsultarSedes
        if any(palabra in input_lower for palabra in palabras_horarios_sede):
            if " en " in input_normalizado_sedes:
                partes = input_normalizado_sedes.split(" en ")
                if len(partes) >= 2:
                    parte_sede = partes[1].strip()
                    # Verificar si la segunda parte contiene una sede conocida
                    for sede in sedes_conocidas:
                        if sede in parte_sede:
                            print(f"‚úÖ Detecci√≥n local horarios de sede: '{sede}' ‚Üí ConsultarSedes")
                            session_attributes["input_original_menu"] = input_transcript
                            return redirigir_a_intencion("ConsultarSedes", session_attributes)
        
        # Detectar patr√≥n: clase + "en" + sede (con normalizaci√≥n)
        if " en " in input_normalizado_sedes:
            partes = input_normalizado_sedes.split(" en ")
            if len(partes) >= 2:
                parte_clase = partes[0].strip()
                parte_sede = partes[1].strip()
                
                # Verificar si la primera parte contiene una clase
                for clase in clases_conocidas:
                    if clase in parte_clase:
                        # Verificar si la segunda parte contiene una sede
                        for sede in sedes_conocidas:
                            if sede in parte_sede:
                                print(f"‚úÖ Detecci√≥n local sede+clase (normalizado): '{clase}' en '{sede}' ‚Üí ConsultaGrupales")
                                session_attributes["input_original_menu"] = input_transcript
                                return redirigir_a_intencion("ConsultaGrupales", session_attributes)
        
        # Si no hay detecci√≥n local, usar Bedrock con prompt mejorado
        print(f"üîç No se detect√≥ localmente, enviando a Bedrock: '{input_transcript}'")
        
        # üÜï MEJORAR EL PROMPT DE BEDROCK CON EJEMPLOS DE NORMALIZACI√ìN
        try:
            from respuestas import consultar_bedrock_generacion
            
            prompt = f"""
            Analiza el siguiente texto del usuario y determina si corresponde claramente a alguna de estas intenciones espec√≠ficas.
            El texto puede contener errores de tipeo que debes interpretar inteligentemente.

            Intenciones disponibles:
            - FQABodytech: Preguntas frecuentes sobre Bodytech, horarios de atenci√≥n, servicios, pol√≠ticas del gimnasio
            - ConsultarSedes: Consultar sedes espec√≠ficas, ubicaciones, horarios de sedes
            - ConsultaGrupales: Clases grupales como yoga, pilates, zumba, spinning, rumba, danza, aqua, funcional, crossfit, bodypump, bodycombat, bodybalance, horarios de clases espec√≠ficas, consultas sobre actividades f√≠sicas en sedes
            - ConsultaInfoPlan: Informaci√≥n del plan del usuario, estado del plan, vencimientos
            - ConsultarInvitados: Consultar invitados del usuario, pol√≠ticas de invitados
            - FQAReferidos: Informaci√≥n sobre referidos, programa de referidos
            - ConsultaIncapacidades: Consultar incapacidades m√©dicas registradas
            - Venta: Informaci√≥n de ventas, planes disponibles, precios, promociones
            - CongelarPlan: Informaci√≥n sobre congelaciones de plan, pausar membres√≠a

            Texto del usuario: "{input_transcript}"

            REGLAS DE CLASIFICACI√ìN:
            - Si menciona CLASES ESPEC√çFICAS (yoga, pilates, zumba, spinning, rumba, danza, aqua, funcional, etc.) ‚Üí ConsultaGrupales
            - Si menciona HORARIOS DE CLASES o HORARIOS DE ACTIVIDADES ‚Üí ConsultaGrupales  
            - Si menciona SEDE + CLASE (ej: "rumba en normandia") ‚Üí ConsultaGrupales
            - Si menciona HORARIOS + NOMBRE DE SEDE (sin clase espec√≠fica) ‚Üí ConsultarSedes
            - Si menciona solo HORARIOS + SEDE (ej: "que horarios tienen en normandia") ‚Üí ConsultarSedes
            - Si es texto aleatorio o sin contexto ‚Üí NO_VALIDO

            EJEMPLOS CON ERRORES DE TIPEO:
            - "que horarios de rumbas tienen en normandie" ‚Üí ConsultaGrupales (rumba + normandia)
            - "yga en chiko" ‚Üí ConsultaGrupales (yoga + chico)
            - "horarios piltes centro maior" ‚Üí ConsultaGrupales (pilates + centro mayor)
            - "que horarios tienen en normandia" ‚Üí ConsultarSedes (horarios generales de sede)
            - "horarios de atencion en chapinero" ‚Üí ConsultarSedes (horarios de sede)
            - "sedes en medelin" ‚Üí ConsultarSedes (medellin)
            - "cuando es spining" ‚Üí ConsultaGrupales (spinning)

            Responde SOLO con el nombre de la intenci√≥n o "NO_VALIDO"
            """
            
            respuesta_bedrock = consultar_bedrock_generacion(prompt)
            intent_clasificado = respuesta_bedrock.strip()
            
            print(f"üîç Respuesta de Bedrock: '{intent_clasificado}'")
            
            # Validar que la intenci√≥n clasificada sea v√°lida
            intenciones_validas = list(opciones_menu.values())
            
            if intent_clasificado in intenciones_validas:
                print(f"‚úÖ Bedrock clasific√≥ como: {intent_clasificado}")
                
                # Configurar session_attributes con el input original para contexto
                session_attributes["input_original_menu"] = input_transcript
                print(f"üîç DEBUG: Guardando input_original_menu = '{input_transcript}'")
                
                resultado_redireccion = redirigir_a_intencion(intent_clasificado, session_attributes)
                
                # ‚úÖ MANEJAR EL CASO CUANDO RETORNA None
                if resultado_redireccion is None:
                    print("üîÑ Redireccion retorn√≥ None - necesita procesar en lambda_handler")
                    # Retornar datos para que lambda_handler contin√∫e el flujo
                    return {
                        "continuar_flujo": True,
                        "intent_name": intent_clasificado,
                        "session_attributes": session_attributes
                    }
                else:
                    # Si la redirecci√≥n retorna una respuesta, enviarla
                    return resultado_redireccion
            else:
                print(f"‚ö†Ô∏è Bedrock respondi√≥: {intent_clasificado} - Mostrando men√∫ nuevamente")
                raise ValueError("Intenci√≥n no v√°lida o input sin sentido")
                
        except Exception as e:
            print(f"‚ùå Error clasificando con Bedrock: {e}")
            
            # Fallback: Mostrar men√∫ nuevamente con sugerencia
            session_attributes["esperando_seleccion_menu"] = "true"
            
            return {
                "sessionState": {
                    "dialogAction": {"type": "ElicitIntent"},
                    "sessionAttributes": session_attributes
                },
                "messages": [{
                    "contentType": "PlainText",
                    "content": (
                        f"ü§î No logr√© entender tu solicitud: '{input_transcript}'\n\n"
                        "Puedes usar:\n"
                        "‚Ä¢ **N√∫meros del 1 al 9** para opciones espec√≠ficas\n"
                        "‚Ä¢ **Texto claro** como 'horarios de yoga' o 'info de mi plan'\n"
                        "‚Ä¢ **N** para finalizar\n\n"
                        "üí¨ ¬øQu√© te gustar√≠a hacer?"
                    )
                }]
            }
def redirigir_a_intencion(intent_clasificado, session_attributes):
    
    """
    Redirige a la intenci√≥n clasificada manteniendo el contexto del input original
    """
    input_original = session_attributes.get("input_original_menu", "")
    
    # Limpiar banderas del men√∫
    session_attributes.pop("esperando_seleccion_menu", None)
    session_attributes.pop("en_flujo_activo", None)  # Limpiar flujo anterior
    
    # ConsultaGrupales - procesar directamente con input original
    if intent_clasificado == "ConsultaGrupales" and input_original:
        print(f"üéØ Procesando ConsultaGrupales directamente con input original: '{input_original}'")
        
        # Importar la funci√≥n necesaria
        from services import extraer_y_validar_slots_grupales
        
        # Procesar directamente el input original
        resultado = extraer_y_validar_slots_grupales(input_original, session_attributes, {
            "name": "ConsultaGrupales",
            "slots": {}
        })
        
        print(f"üîç Resultado de extracci√≥n directa: {resultado}")
        
        # Si la funci√≥n devuelve una respuesta directa, enviarla
        if resultado and resultado.get("sessionState"):
            return resultado
        
        # Si hay error, enviar el error
        if resultado and resultado.get("error"):
            return resultado["error"]
        
        # Si se extrajeron par√°metros, configurar para continuar el flujo
        if (resultado 
            and not resultado.get("error")
            and (resultado.get("ciudad_id") or resultado.get("sede_id") or resultado.get("clase_id"))):
            
            print("‚úÖ Par√°metros extra√≠dos correctamente del input original!")
            
            # Actualizar session_attributes con los datos detectados
            if resultado.get("ciudad_id"):
                session_attributes["ciudad_id"] = str(resultado["ciudad_id"])
                session_attributes["ciudad_nombre"] = resultado["ciudad_nombre"]
            
            if resultado.get("sede_id"):
                session_attributes["sede_id"] = str(resultado["sede_id"])
                session_attributes["sede_nombre"] = resultado["sede_nombre"]
            
            if resultado.get("clase_id"):
                session_attributes["clase_id"] = str(resultado["clase_id"])
                session_attributes["clase_nombre"] = resultado["clase_nombre"]
            
            if resultado.get("fecha"):
                session_attributes["fecha_temporal"] = resultado["fecha"]
            
            # ‚úÖ CRUCIAL: NO CREAR RESPUESTA EST√ÅTICA - DEJAR QUE CONTIN√öE EL FLUJO
            session_attributes["procesar_con_datos_extraidos"] = "true"
            session_attributes["input_original_menu"] = input_original
            
            # ‚úÖ RETORNAR ESTRUCTURA PARA CONTINUAR EL FLUJO
            print("üîÑ Continuando al lambda_handler para mostrar sedes...")
            return {
                "continuar_flujo": True,
                "intent_name": "ConsultaGrupales",
                "session_attributes": session_attributes
            }
    
    elif intent_clasificado == "ConsultarSedes":
        print("üîç Procesando ConsultarSedes con extracci√≥n autom√°tica...")
        
        # Procesar directamente el input original
        from services import extraer_y_validar_slots_sedes
        resultado = extraer_y_validar_slots_sedes(input_original, session_attributes, {
            "name": "ConsultarSedes",
            "slots": {}
        })
        
        print(f"üîç Resultado de extracci√≥n sedes: {resultado}")
        
        # Si la funci√≥n devuelve una respuesta directa, enviarla
        if resultado and resultado.get("sessionState"):
            return resultado
        
        # Si hay error, enviar el error
        if resultado and resultado.get("error"):
            return resultado["error"]
        
        # Si se extrajeron par√°metros, configurar para continuar el flujo
        if (resultado 
            and not resultado.get("error")
            and (resultado.get("ciudad_id") or resultado.get("sede_id") or resultado.get("categoria_nombre"))):
            
            print("‚úÖ Par√°metros de sedes extra√≠dos correctamente del input original!")
            
            # Actualizar session_attributes con los datos detectados
            if resultado.get("ciudad_id"):
                session_attributes["ciudad_id"] = str(resultado["ciudad_id"])
                session_attributes["ciudad_nombre"] = resultado["ciudad_nombre"]
            
            if resultado.get("sede_id"):
                session_attributes["sede_id"] = str(resultado["sede_id"])
                session_attributes["sede_nombre"] = resultado["sede_nombre"]
            
            if resultado.get("categoria_nombre"):
                session_attributes["categoria_detectada"] = resultado["categoria_nombre"]
            
            if resultado.get("tipo_consulta"):
                session_attributes["tipo_consulta_temporal"] = resultado["tipo_consulta"]
            
            # ‚úÖ CRUCIAL: NO CREAR RESPUESTA EST√ÅTICA - DEJAR QUE CONTIN√öE EL FLUJO
            session_attributes["procesar_con_datos_extraidos"] = "true"
            session_attributes["input_original_menu"] = input_original
            
            # ‚úÖ RETORNAR ESTRUCTURA PARA CONTINUAR EL FLUJO
            print("üîÑ Continuando al lambda_handler para mostrar sedes de ConsultarSedes...")
            return {
                "continuar_flujo": True,
                "intent_name": "ConsultarSedes",
                "session_attributes": session_attributes
            }
    
    # Para otras intenciones o ConsultaGrupales sin datos extra√≠dos, usar flujo normal
    intents_requieren_doc = {"ConsultaInfoPlan", "ConsultarInvitados", "ConsultaIncapacidades", "FQAReferidos", "CongelarPlan"}
    
    if intent_clasificado in intents_requieren_doc:
        intenciones_con_documento = session_attributes.get("intenciones_con_documento", "")
        intenciones_set = set(intenciones_con_documento.split(",")) if intenciones_con_documento else set()
        
        # Agregar la nueva intenci√≥n al conjunto
        intenciones_set.add(intent_clasificado)
        session_attributes["intenciones_con_documento"] = ",".join(intenciones_set)
        
        # ‚úÖ Verificar si YA HAY un documento registrado previamente
        tiene_documento_previo = (
            session_attributes.get("document_type_id") and 
            session_attributes.get("document_number")
        )
        
        print(f"üîç ===== DEBUG VALIDACI√ìN DOCUMENTO PREVIO (MEN√ö) =====")
        print(f"üîç Intent actual: {intent_clasificado}")
        print(f"üîç intenciones_set: {intenciones_set}")
        print(f"üîç Longitud intenciones_set: {len(intenciones_set)}")
        print(f"üîç Tiene documento previo: {tiene_documento_previo}")
        print(f"üîç document_type_id: {session_attributes.get('document_type_id')}")
        print(f"üîç document_number: {session_attributes.get('document_number')}")
        print(f"üîç preguntando_otro_documento: {session_attributes.get('preguntando_otro_documento')}")
        print(f"üîç cambiando_documento: {session_attributes.get('cambiando_documento')}")
        print(f"üîç =====================================================")
        
        # Si ya tiene documento previo Y est√° seleccionando nueva intenci√≥n
        if (
            tiene_documento_previo
            and not session_attributes.get("preguntando_otro_documento")
            and not session_attributes.get("cambiando_documento")
            and session_attributes.get("acepto_politicas") == "true"
        ):
            print(f"üîç ‚úÖ ACTIVANDO pregunta de otro documento para {intent_clasificado} desde men√∫")
            session_attributes["preguntando_otro_documento"] = "true"
            session_attributes["cambiando_documento"] = ""
            session_attributes["intencion_tras_documento"] = intent_clasificado  # ‚úÖ AGREGAR ESTA L√çNEA
            session_attributes["en_flujo_activo"] = intent_clasificado  # ‚úÖ Establecer flujo activo
            
            return {
                "sessionState": {
                    "dialogAction": {"type": "ElicitSlot", "slotToElicit": "cambiar_documento"},
                    "intent": {
                        "name": intent_clasificado,
                        "state": "InProgress",
                        "slots": {}
                    },
                    "sessionAttributes": session_attributes
                },
                "messages": [{
                    "contentType": "PlainText",
                    "content": "¬øQuieres consultar con otro documento o seguir usando el que ya indicaste?\n\n"
                    "üí¨ **Puedes Decirme:** 'Otro documento' o 'Mismo documento'\n\n"
                }]
            }
    
    # Limpiar datos de sesi√≥n pero mantener algunos b√°sicos
    datos_basicos = {
        "acepto_politicas": session_attributes.get("acepto_politicas"),
        "document_type_id": session_attributes.get("document_type_id"),
        "document_type_raw": session_attributes.get("document_type_raw"),
        "document_number": session_attributes.get("document_number"),
        "intenciones_con_documento": session_attributes.get("intenciones_con_documento"),
        "input_original_menu": session_attributes.get("input_original_menu")  # ‚úÖ PRESERVAR input original
    }
    
    # Limpiar session_attributes manteniendo solo datos b√°sicos
    session_attributes.clear()
    for k, v in datos_basicos.items():
        if v is not None:
            session_attributes[k] = v
    
    # Configuraciones espec√≠ficas por intenci√≥n
    if intent_clasificado == "ConsultarSedes":
        # üÜï Procesar input original para extraer par√°metros autom√°ticamente
        input_original = session_attributes.get("input_original_menu", "")
        
        print(f"üîç DEBUG ConsultarSedes: input_original = '{input_original}'")
        print(f"üîç DEBUG ConsultarSedes: session_attributes keys = {list(session_attributes.keys())}")
        
        if input_original:
            print(f"üéØ Procesando ConsultarSedes con input original: '{input_original}'")
            
            resultado_automatico = procesar_input_original_sedes(input_original, session_attributes)
            
            # Si el procesamiento autom√°tico fue exitoso, devolverlo
            if resultado_automatico:
                return resultado_automatico
        
        # Si no hay input original o no se pudo procesar autom√°ticamente, flujo normal
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {
                    "name": intent_clasificado,
                    "slots": {},
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": "¬°Perfecto! Te ayudo a consultar informaci√≥n de sedes y horarios üè¢\n\n¬øEn qu√© ciudad deseas consultar las sedes?"
            }]
        }
    
    elif intent_clasificado == "ConsultaGrupales":
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {
                    "name": intent_clasificado,
                    "slots": {},
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": "¬°Excelente! Te ayudo a consultar clases grupales üèÉ‚Äç‚ôÇÔ∏è\n\n¬øEn qu√© ciudad deseas consultar las clases?"
            }]
        }
    
    elif intent_clasificado == "ConsultaInfoPlan":
        # Configurar flujo activo
        session_attributes["en_flujo_activo"] = intent_clasificado
        
        from services import validar_documento_usuario
        
        # Crear intent mock para validar_documento_usuario
        intent_mock = {
            "name": intent_clasificado,
            "slots": {},
            "state": "InProgress"
        }
        
        # Llamar a validar_documento_usuario que maneja todo el flujo
        document_type_id, document_number, session_attributes, respuesta_incompleta = validar_documento_usuario(
            {}, session_attributes, "", intent_mock
        )
        
        # Si necesita m√°s datos, retornar la respuesta de validaci√≥n
        if respuesta_incompleta:
            return respuesta_incompleta
        
        
        # Si ya tiene todos los datos, continuar con el flujo normal de la intenci√≥n
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "intent": {
                    "name": intent_clasificado,
                    "slots": {},
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": "¬°Perfecto! Consultando informaci√≥n de tu plan üìÖ"
            }]
        }
    
    elif intent_clasificado in ["ConsultarInvitados", "FQAReferidos", "ConsultaIncapacidades", "CongelarPlan"]:
        # Configurar flujo activo
        session_attributes["en_flujo_activo"] = intent_clasificado
        
        from services import validar_documento_usuario
        
        # Crear intent mock para validar_documento_usuario
        intent_mock = {
            "name": intent_clasificado,
            "slots": {},
            "state": "InProgress"
        }
        
        # Llamar a validar_documento_usuario que maneja todo el flujo
        document_type_id, document_number, session_attributes, respuesta_incompleta = validar_documento_usuario(
            {}, session_attributes, "", intent_mock
        )
        
        # Si necesita m√°s datos, retornar la respuesta de validaci√≥n
        if respuesta_incompleta:
            return respuesta_incompleta
        
        # Si ya tiene todos los datos, continuar con el flujo normal de la intenci√≥n
        mensajes_cuando_tiene_datos = {
            "ConsultarInvitados": "¬°Perfecto! Consultando tus invitados üë•",
            "FQAReferidos": "¬°Excelente! Consultando informaci√≥n de tus referidos üèÜ", 
            "ConsultaIncapacidades": "¬°Perfecto! Consultando tus incapacidades üßæ",
            "CongelarPlan": "¬°Entendido! Consultando informaci√≥n sobre congelaciones ‚ùÑÔ∏è"
        }
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "intent": {
                    "name": intent_clasificado,
                    "slots": {},
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": mensajes_cuando_tiene_datos.get(intent_clasificado, f"¬°Perfecto! Procesando tu consulta üìã")
            }]
        }
    
    # Para FQABodytech y Venta - intenciones que NO requieren documento
    else:
        # Configurar flujo activo para todas las intenciones
        session_attributes["en_flujo_activo"] = intent_clasificado
        
        mensajes_bienvenida = {
            "FQABodytech": "¬°Excelente! Te ayudo con preguntas frecuentes sobre Bodytech üèãÔ∏è‚Äç‚ôÇÔ∏è\n\n¬øQu√© informaci√≥n espec√≠fica necesitas? Por ejemplo:\n‚Ä¢ Horarios de atenci√≥n\n‚Ä¢ Servicios disponibles\n‚Ä¢ Pol√≠ticas del gimnasio\n‚Ä¢ Informaci√≥n sobre clases\n\nüí¨ **Escribe tu pregunta:**",
            "Venta": "¬°Perfecto! Te ayudo con informaci√≥n de ventas üõçÔ∏è\n\n¬øQu√© informaci√≥n de ventas necesitas? Por ejemplo:\n‚Ä¢ Planes disponibles\n‚Ä¢ Precios y promociones\n‚Ä¢ Servicios adicionales\n‚Ä¢ M√©todos de pago\n\nüí¨ **Escribe tu consulta:**"
        }
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "intent": {
                    "name": intent_clasificado,
                    "slots": {},
                    "state": "InProgress"
                },
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": mensajes_bienvenida.get(intent_clasificado, f"¬°Perfecto! ¬øEn qu√© puedo ayudarte con {intent_clasificado}?")
            }]
        }

def _procesar_otra_fecha(session_attributes):
    """Procesa transici√≥n a otra fecha manteniendo ciudad, sede y clase"""
    print("‚úÖ Transici√≥n: OTRA FECHA")
    
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    sede_actual = session_attributes.get("sede_nombre")
    clase_actual = session_attributes.get("clase_nombre")
    
    if not ciudad_actual or not sede_actual:
        print("‚ùå Faltan datos de ciudad o sede para otra fecha")
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultaGrupales", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{"contentType": "PlainText", "content": "¬øEn qu√© ciudad y sede deseas consultar otra fecha?"}]
        }
    
    # Limpiar solo datos espec√≠ficos de fecha, mantener todo lo dem√°s
    keys_to_remove = ["fecha", "esperando_transicion_grupales"]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Configurar slots manteniendo ciudad, sede y clase (si existe)
    slots_nuevos = {
        "ciudad": {
            "value": {
                "originalValue": ciudad_actual,
                "resolvedValues": [ciudad_actual],
                "interpretedValue": ciudad_actual
            },
            "shape": "Scalar"
        },
        "sede": {
            "value": {
                "originalValue": sede_actual,
                "resolvedValues": [sede_actual],
                "interpretedValue": sede_actual
            },
            "shape": "Scalar"
        }
    }
    
    # Si hay clase espec√≠fica, mantenerla tambi√©n
    if clase_actual:
        slots_nuevos["clase"] = {
            "value": {
                "originalValue": clase_actual,
                "resolvedValues": [clase_actual],
                "interpretedValue": clase_actual
            },
            "shape": "Scalar"
        }
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar {clase_actual} en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    else:
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar las clases en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    
    # Marcar que estamos en flujo activo
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    print(f"‚úÖ Par√°metros mantenidos - Ciudad: {ciudad_actual}, Sede: {sede_actual}, Clase: {clase_actual or 'Todas'}")
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "fecha"},
            "intent": {
                "name": "ConsultaGrupales",
                "slots": slots_nuevos,
                "state": "InProgress"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": f"{mensaje_fecha}\n\n¬øPara qu√© fecha deseas consultar? Puedes escribir:\n‚Ä¢ YYYY-MM-DD (2025-01-15)\n‚Ä¢ DD de MMMM (15 de enero)\n‚Ä¢ DD/MM (15/01)\n‚Ä¢ 'hoy' o 'ma√±ana'"
        }]
    }
    print("‚úÖ Transici√≥n: OTRA FECHA")
    
    ciudad_actual = session_attributes.get("ciudad_nombre") or session_attributes.get("ciudad")
    sede_actual = session_attributes.get("sede_nombre")
    clase_actual = session_attributes.get("clase_nombre")
    
    if not ciudad_actual or not sede_actual:
        print("‚ùå Faltan datos de ciudad o sede para otra fecha")
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitSlot", "slotToElicit": "ciudad"},
                "intent": {"name": "ConsultaGrupales", "state": "InProgress", "slots": {}},
                "sessionAttributes": session_attributes
            },
            "messages": [{"contentType": "PlainText", "content": "¬øEn qu√© ciudad y sede deseas consultar otra fecha?"}]
        }
    
    # Limpiar solo datos espec√≠ficos de fecha, mantener todo lo dem√°s
    keys_to_remove = ["fecha", "esperando_transicion_grupales"]
    for key in keys_to_remove:
        session_attributes.pop(key, None)
    
    # Configurar slots manteniendo ciudad, sede y clase (si existe)
    slots_nuevos = {
        "ciudad": {
            "value": {
                "originalValue": ciudad_actual,
                "resolvedValues": [ciudad_actual],
                "interpretedValue": ciudad_actual
            },
            "shape": "Scalar"
        },
        "sede": {
            "value": {
                "originalValue": sede_actual,
                "resolvedValues": [sede_actual],
                "interpretedValue": sede_actual
            },
            "shape": "Scalar"
        }
    }
    
    # Si hay clase espec√≠fica, mantenerla tambi√©n
    if clase_actual:
        slots_nuevos["clase"] = {
            "value": {
                "originalValue": clase_actual,
                "resolvedValues": [clase_actual],
                "interpretedValue": clase_actual
            },
            "shape": "Scalar"
        }
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar {clase_actual} en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    else:
        mensaje_fecha = f"¬°Perfecto! Te ayudo a consultar las clases en la sede {sede_actual} ({ciudad_actual}) para otra fecha. üìÖ"
    
    # Marcar que estamos en flujo activo
    session_attributes["en_flujo_activo"] = "ConsultaGrupales"
    
    print(f"‚úÖ Par√°metros mantenidos - Ciudad: {ciudad_actual}, Sede: {sede_actual}, Clase: {clase_actual or 'Todas'}")
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitSlot", "slotToElicit": "fecha"},
            "intent": {
                "name": "ConsultaGrupales",
                "slots": slots_nuevos,
                "state": "InProgress"
            },
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": f"{mensaje_fecha}\n\n¬øPara qu√© fecha deseas consultar? Puedes escribir:\n‚Ä¢ YYYY-MM-DD (2025-01-15)\n‚Ä¢ DD de MMMM (15 de enero)\n‚Ä¢ DD/MM (15/01)\n‚Ä¢ 'hoy' o 'ma√±ana'"
        }]
    }

#####################################
# Manejar logica de transicion asesor
####################################

def incrementar_contador_no_reconocidas(session_attributes):
    """Incrementa el contador de entradas no reconocidas"""
    contador_actual = int(session_attributes.get("entradas_no_reconocidas", 0))
    contador_nuevo = contador_actual + 1
    session_attributes["entradas_no_reconocidas"] = str(contador_nuevo)
    
    print(f"üî¢ Contador entradas no reconocidas: {contador_nuevo}")
    return contador_nuevo

def resetear_contador_no_reconocidas(session_attributes):
    """Resetea el contador de entradas no reconocidas"""
    session_attributes.pop("entradas_no_reconocidas", None)
    session_attributes.pop("esperando_respuesta_asesor", None)
    print("‚úÖ Contador de entradas no reconocidas reseteado")

def debe_ofrecer_asesor(session_attributes):
    """Verifica si debe ofrecer hablar con asesor"""
    contador = int(session_attributes.get("entradas_no_reconocidas", 0))
    return contador >= 2

def ofrecer_hablar_con_asesor(session_attributes):
    """Ofrece la opci√≥n de hablar con un asesor"""
    session_attributes["esperando_respuesta_asesor"] = "true"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "ü§î Veo que no he logrado entender tus √∫ltimas consultas.\n\n"
                "¬øTe gustar√≠a hablar con uno de nuestros asesores para recibir ayuda personalizada?\n\n"
                "üí¨ Responde:\n"
                "‚Ä¢ **'S√≠'** - Para conectarte con un asesor\n"
                "‚Ä¢ **'No'** - Para volver al men√∫ principal\n\n"
                "¬øQu√© prefieres?"
            )
        }]
    }

def procesar_respuesta_asesor(input_transcript, session_attributes):
    """Procesa la respuesta del usuario sobre hablar con asesor"""
    if session_attributes.get("esperando_respuesta_asesor") != "true":
        return None
    
    input_lower = input_transcript.lower().strip()
    print(f"üîç Procesando respuesta asesor: '{input_lower}'")
    
    # Limpiar bandera
    session_attributes.pop("esperando_respuesta_asesor", None)
    resetear_contador_no_reconocidas(session_attributes)
    
    # Respuestas afirmativas - solicitar calificaci√≥n ANTES de pasar a asesor
    if any(palabra in input_lower for palabra in [
        "si", "s√≠", "yes", "claro", "vale", "ok", "por supuesto", 
        "quiero", "necesito", "asesor", "ayuda"
    ]):
        print("‚úÖ Usuario quiere hablar con asesor - solicitando calificaci√≥n primero")
        
        # üÜï MARCAR QUE DESPU√âS DE CALIFICAR VA A ASESOR
        session_attributes["despues_calificacion_asesor"] = "true"
        session_attributes["esperando_calificacion"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "¬°Perfecto! Antes de conectarte con un asesor, nos gustar√≠a conocer tu experiencia con el asistente virtual.\n\n"
                    "¬øPodr√≠as calificar tu experiencia?\n\n"
                    "‚≠ê 1 estrella - Muy mala\n"
                    "‚≠ê‚≠ê 2 estrellas - Mala\n"
                    "‚≠ê‚≠ê‚≠ê 3 estrellas - Regular\n"
                    "‚≠ê‚≠ê‚≠ê‚≠ê 4 estrellas - Buena\n"
                    "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5 estrellas - Excelente\n\n"
                    "üí¨ **Responde con un n√∫mero del 1 al 5:**"
                )
            }]
        }
    
    # Respuestas negativas - volver al men√∫ principal
    elif any(palabra in input_lower for palabra in [
        "no", "nada", "gracias", "menu", "men√∫", "principal", "no gracias"
    ]):
        print("‚úÖ Usuario no quiere asesor - volviendo al men√∫ principal")
        return mostrar_menu_principal(session_attributes)
    
    # Respuesta no clara - preguntar de nuevo
    else:
        print(f"‚ùå Respuesta no clara sobre asesor: '{input_transcript}'")
        session_attributes["esperando_respuesta_asesor"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "ü§î No entend√≠ tu respuesta.\n\n"
                    "¬øQuieres hablar con un asesor?\n\n"
                    "üí¨ Responde solo:\n"
                    "‚Ä¢ **'S√≠'** - Para conectarte con un asesor\n"
                    "‚Ä¢ **'No'** - Para volver al men√∫ principal"
                )
            }]
        }

###############################
# Verificar si es input valido
###############################

def es_input_valido(input_transcript):
    """
    Valida si el input del usuario es texto coherente o solo caracteres sin sentido
    """
    
    # Limpiar el input
    texto_limpio = input_transcript.strip().lower()
    
    # 1. Si est√° vac√≠o, es inv√°lido
    if not texto_limpio:
        return False
    
    # ‚úÖ NUEVO: Si es solo n√∫meros (posible documento), es v√°lido
    if texto_limpio.isdigit() and 4 <= len(texto_limpio) <= 15:
        print(f"‚úÖ Input v√°lido (n√∫mero de documento): '{texto_limpio}'")
        return True
    
    # 2. Si es solo n√∫meros largos sin sentido (m√°s de 15 d√≠gitos)
    if texto_limpio.isdigit() and len(texto_limpio) > 15:
        return False
    
    # 3. Si tiene m√°s del 70% de caracteres repetidos o sin sentido
    caracteres_unicos = len(set(texto_limpio.replace(" ", "")))
    total_caracteres = len(texto_limpio.replace(" ", ""))
    
    if total_caracteres > 5 and caracteres_unicos / total_caracteres < 0.3:
        print(f"üö´ Texto con pocos caracteres √∫nicos: {caracteres_unicos}/{total_caracteres}")
        return False
    
    # 4. ‚úÖ MEJORAR: Detectar patrones de tecleo aleatorio (pero excluir palabras v√°lidas)
    # Lista de palabras v√°lidas que pueden tener muchas consonantes
    palabras_validas_consonantes = [
        "country", "centro", "rumba", "spinning", "crossfit", "strength", "strong",
        "chapinero", "normandia", "outlet", "portal", "tintal", "hayuelos", "cedritos",
        "horarios", "tienen", "grupales", "clases", "horario", "consultar"
    ]
    
    # Solo aplicar filtro de consonantes si NO contiene palabras v√°lidas conocidas
    contiene_palabra_valida = any(palabra in texto_limpio for palabra in palabras_validas_consonantes)
    
    if not contiene_palabra_valida:
        patron_sin_sentido = re.compile(r'[bcdfghjklmnpqrstvwxyz]{6,}')  # Aumentar umbral a 6
        if patron_sin_sentido.search(texto_limpio):
            print(f"üö´ Patr√≥n de consonantes detectado: {texto_limpio}")
            return False
    
    # 5. Detectar secuencias de teclado obvias
    secuencias_teclado = [
        'qwerty', 'asdf', 'zxcv', 'qaz', 'wsx', 'edc', 'rfv', 'tgb', 'yhn', 'ujm',
        'qlllq', 'asklj', 'lkjh', 'mnbv', 'poiu', 'wert', 'dfgh', 'cvbn'
    ]
    
    for secuencia in secuencias_teclado:
        if secuencia in texto_limpio:
            print(f"üö´ Secuencia de teclado detectada: {secuencia}")
            return False
    
    # 6. Si es muy corto pero no tiene sentido (menos de 3 caracteres v√°lidos)
    if len(texto_limpio.replace(" ", "")) < 3 and not any(palabra in texto_limpio for palabra in [
        "si", "no", "ok", "hola", "bye", "m", "n", "1", "2", "3", "4", "5", "6", "7", "8", "9"
    ]):
        return False
    
    # 7. Detectar si NO tiene ninguna vocal (excepto n√∫meros y palabras muy cortas)
    if (len(texto_limpio) > 2 and 
        not re.search(r'[aeiou√°√©√≠√≥√∫]', texto_limpio) and 
        not texto_limpio.isdigit()):  # ‚úÖ AGREGAR esta condici√≥n
        print(f"üö´ Texto sin vocales: {texto_limpio}")
        return False
    
    print(f"‚úÖ Input v√°lido: '{texto_limpio}'")
    return True#####################################
# Manejar logica de transicion asesor
####################################

def incrementar_contador_no_reconocidas(session_attributes):
    """Incrementa el contador de entradas no reconocidas"""
    contador_actual = int(session_attributes.get("entradas_no_reconocidas", 0))
    contador_nuevo = contador_actual + 1
    session_attributes["entradas_no_reconocidas"] = str(contador_nuevo)
    
    print(f"üî¢ Contador entradas no reconocidas: {contador_nuevo}")
    return contador_nuevo

def resetear_contador_no_reconocidas(session_attributes):
    """Resetea el contador de entradas no reconocidas"""
    session_attributes.pop("entradas_no_reconocidas", None)
    session_attributes.pop("esperando_respuesta_asesor", None)
    print("‚úÖ Contador de entradas no reconocidas reseteado")

def debe_ofrecer_asesor(session_attributes):
    """Verifica si debe ofrecer hablar con asesor"""
    contador = int(session_attributes.get("entradas_no_reconocidas", 0))
    return contador >= 2

def ofrecer_hablar_con_asesor(session_attributes):
    """Ofrece la opci√≥n de hablar con un asesor"""
    session_attributes["esperando_respuesta_asesor"] = "true"
    
    return {
        "sessionState": {
            "dialogAction": {"type": "ElicitIntent"},
            "sessionAttributes": session_attributes
        },
        "messages": [{
            "contentType": "PlainText",
            "content": (
                "ü§î Veo que no he logrado entender tus √∫ltimas consultas.\n\n"
                "¬øTe gustar√≠a hablar con uno de nuestros asesores para recibir ayuda personalizada?\n\n"
                "üí¨ Responde:\n"
                "‚Ä¢ **'S√≠'** - Para conectarte con un asesor\n"
                "‚Ä¢ **'No'** - Para volver al men√∫ principal\n\n"
                "¬øQu√© prefieres?"
            )
        }]
    }

def procesar_respuesta_asesor(input_transcript, session_attributes):
    """Procesa la respuesta del usuario sobre hablar con asesor"""
    if session_attributes.get("esperando_respuesta_asesor") != "true":
        return None
    
    input_lower = input_transcript.lower().strip()
    print(f"üîç Procesando respuesta asesor: '{input_lower}'")
    
    # Limpiar bandera
    session_attributes.pop("esperando_respuesta_asesor", None)
    resetear_contador_no_reconocidas(session_attributes)
    
    # Respuestas afirmativas - solicitar calificaci√≥n ANTES de pasar a asesor
    if any(palabra in input_lower for palabra in [
        "si", "s√≠", "yes", "claro", "vale", "ok", "por supuesto", 
        "quiero", "necesito", "asesor", "ayuda"
    ]):
        print("‚úÖ Usuario quiere hablar con asesor - solicitando calificaci√≥n primero")
        
        # üÜï MARCAR QUE DESPU√âS DE CALIFICAR VA A ASESOR
        session_attributes["despues_calificacion_asesor"] = "true"
        session_attributes["esperando_calificacion"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "¬°Perfecto! Antes de conectarte con un asesor, nos gustar√≠a conocer tu experiencia con el asistente virtual.\n\n"
                    "¬øPodr√≠as calificar tu experiencia?\n\n"
                    "‚≠ê 1 estrella - Muy mala\n"
                    "‚≠ê‚≠ê 2 estrellas - Mala\n"
                    "‚≠ê‚≠ê‚≠ê 3 estrellas - Regular\n"
                    "‚≠ê‚≠ê‚≠ê‚≠ê 4 estrellas - Buena\n"
                    "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5 estrellas - Excelente\n\n"
                    "üí¨ **Responde con un n√∫mero del 1 al 5:**"
                )
            }]
        }
    
    # Respuestas negativas - volver al men√∫ principal
    elif any(palabra in input_lower for palabra in [
        "no", "nada", "gracias", "menu", "men√∫", "principal", "no gracias"
    ]):
        print("‚úÖ Usuario no quiere asesor - volviendo al men√∫ principal")
        return mostrar_menu_principal(session_attributes)
    
    # Respuesta no clara - preguntar de nuevo
    else:
        print(f"‚ùå Respuesta no clara sobre asesor: '{input_transcript}'")
        session_attributes["esperando_respuesta_asesor"] = "true"
        
        return {
            "sessionState": {
                "dialogAction": {"type": "ElicitIntent"},
                "sessionAttributes": session_attributes
            },
            "messages": [{
                "contentType": "PlainText",
                "content": (
                    "ü§î No entend√≠ tu respuesta.\n\n"
                    "¬øQuieres hablar con un asesor?\n\n"
                    "üí¨ Responde solo:\n"
                    "‚Ä¢ **'S√≠'** - Para conectarte con un asesor\n"
                    "‚Ä¢ **'No'** - Para volver al men√∫ principal"
                )
            }]
        }
